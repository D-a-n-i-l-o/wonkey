namespace sokol

#import "<libc>"

using libc..

#if __HOSTOS__="windows"

#import "<libgdi32.a>"

#elseif __HOSTOS__="macos"

#import "WX_CC_OPTS_MACOS=-fobjc-arc"
#import "WX_CPP_OPTS_MACOS=-fobjc-arc"

#import "<CoreFoundation.framework>"
#import "<Metal.framework>"
#import "<Cocoa.framework>"
#import "<MetalKit.framework>"
#import "<Quartz.framework>"

#endif

#import "native/*.h"

#import "native/sokol_app.h"
#import "native/sokol_gfx.h"
#import "native/sokol_glue.h"

#if __HOSTOS__="macos"
    #import "native/sokol.m" 'ObjC
    #import "native/sokol.mm" 'ObjC++
#else
    #import "native/sokol.c" 'C
    #import "native/sokol.cpp" 'C++
#end

extern

'//=================================================================================================================================
'//
'//
'// sokol_glue.h
'//
'//
'//=================================================================================================================================

function sapp_sgcontext:sg_context_desc()

'//=================================================================================================================================
'//
'//
'// sokol_app.h
'//
'//
'//=================================================================================================================================

#rem
    sokol_app.h -- cross-platform application wrapper

    Project URL: https://github.com/floooh/sokol

    Do this:
        #define SOKOL_IMPL or
        #define SOKOL_APP_IMPL
    before you include this file in *one* C or C++ file to create the
    implementation.

    In the same place define one of the following to select the 3D-API
    which should be initialized by sokol_app.h (this must also match
    the backend selected for sokol_gfx.h if both are used in the same
    project):

        #define SOKOL_GLCORE33
        #define SOKOL_GLES2
        #define SOKOL_GLES3
        #define SOKOL_D3D11
        #define SOKOL_METAL
        #define SOKOL_WGPU

    Optionally provide the following defines with your own implementations:

        SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))
        SOKOL_LOG(msg)      - your own logging function (default: puts(msg))
        SOKOL_UNREACHABLE() - a guard macro for unreachable code (default: assert(false))
        SOKOL_ABORT()       - called after an unrecoverable error (default: abort())
        SOKOL_WIN32_FORCE_MAIN  - define this on Win32 to use a main() entry point instead of WinMain
        SOKOL_NO_ENTRY      - define this if sokol_app.h shouldn't "hijack" the main() function
        SOKOL_APP_API_DECL  - public function declaration prefix (default: extern)
        SOKOL_API_DECL      - same as SOKOL_APP_API_DECL
        SOKOL_API_IMPL      - public function implementation prefix (default: -)
        SOKOL_CALLOC        - your own calloc function (default: calloc(n, s))
        SOKOL_FREE          - your own free function (default: free(p))

    Optionally define the following to force debug checks and validations
    even in release mode:

        SOKOL_DEBUG         - by default this is defined if _DEBUG is defined

    If sokol_app.h is compiled as a DLL, define the following before
    including the declaration or implementation:

        SOKOL_DLL

    On Windows, SOKOL_DLL will define SOKOL_APP_API_DECL as __declspec(dllexport)
    or __declspec(dllimport) as needed.

    If you use sokol_app.h together with sokol_gfx.h, include both headers
    in the implementation source file, and include sokol_app.h before
    sokol_gfx.h since sokol_app.h will also include the required 3D-API
    headers.

    On Windows, a minimal 'GL header' and function loader is integrated which
    contains just enough of GL for sokol_gfx.h. If you want to use your own
    GL header-generator/loader instead, define SOKOL_WIN32_NO_GL_LOADER
    before including the implementation part of sokol_app.h.

    To make use of the integrated GL loader, simply include the sokol_app.h
    implementation before the sokol_gfx.h implementation.

    For example code, see https://github.com/floooh/sokol-samples/tree/master/sapp

    Portions of the Windows and Linux GL initialization and event code have been
    taken from GLFW (http://www.glfw.org/)

    iOS onscreen keyboard support 'inspired' by libgdx.

    Link with the following system libraries:

    - on macOS with Metal: Cocoa, QuartzCore, Metal, MetalKit
    - on macOS with GL: Cocoa, QuartzCore, OpenGL
    - on iOS with Metal: Foundation, UIKit, Metal, MetalKit
    - on iOS with GL: Foundation, UIKit, OpenGLES, GLKit
    - on Linux: X11, Xi, Xcursor, GL, dl, pthread, m(?)
    - on Android: GLESv3, EGL, log, android
    - on Windows: no action needed, libs are defined in-source via pragma-comment-lib

    On Linux, you also need to use the -pthread compiler and linker option, otherwise weird
    things will happen, see here for details: https://github.com/floooh/sokol/issues/376

    Building for UWP requires a recent Visual Studio toolchain and Windows SDK
    (at least VS2019 and Windows SDK 10.0.19041.0). When the UWP backend is
    selected, the sokol_app.h implementation must be compiled as C++17.

    On macOS and iOS, the implementation must be compiled as Objective-C.

    FEATURE OVERVIEW
    ================
    sokol_app.h provides a minimalistic cross-platform API which
    implements the 'application-wrapper' parts of a 3D application:

    - a common application entry function
    - creates a window and 3D-API context/device with a 'default framebuffer'
    - makes the rendered frame visible
    - provides keyboard-, mouse- and low-level touch-events
    - platforms: MacOS, iOS, HTML5, Win32, Linux, Android (TODO: RaspberryPi)
    - 3D-APIs: Metal, D3D11, GL3.2, GLES2, GLES3, WebGL, WebGL2

    FEATURE/PLATFORM MATRIX
    =======================
                        | Windows | macOS | Linux |  iOS  | Android | UWP  | Raspi | HTML5
    --------------------+---------+-------+-------+-------+---------+------+-------+-------
    gl 3.x              | YES     | YES   | YES   | ---   | ---     | ---  | ---   | ---
    gles2/webgl         | ---     | ---   | ---   | YES   | YES     | ---  | TODO  | YES
    gles3/webgl2        | ---     | ---   | ---   | YES   | YES     | ---  | ---   | YES
    metal               | ---     | YES   | ---   | YES   | ---     | ---  | ---   | ---
    d3d11               | YES     | ---   | ---   | ---   | ---     | YES  | ---   | ---
    KEY_DOWN            | YES     | YES   | YES   | SOME  | TODO    | YES  | TODO  | YES
    KEY_UP              | YES     | YES   | YES   | SOME  | TODO    | YES  | TODO  | YES
    CHAR                | YES     | YES   | YES   | YES   | TODO    | YES  | TODO  | YES
    MOUSE_DOWN          | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    MOUSE_UP            | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    MOUSE_SCROLL        | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    MOUSE_MOVE          | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    MOUSE_ENTER         | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    MOUSE_LEAVE         | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    TOUCHES_BEGAN       | ---     | ---   | ---   | YES   | YES     | TODO | ---   | YES
    TOUCHES_MOVED       | ---     | ---   | ---   | YES   | YES     | TODO | ---   | YES
    TOUCHES_ENDED       | ---     | ---   | ---   | YES   | YES     | TODO | ---   | YES
    TOUCHES_CANCELLED   | ---     | ---   | ---   | YES   | YES     | TODO | ---   | YES
    RESIZED             | YES     | YES   | YES   | YES   | YES     | YES  | ---   | YES
    ICONIFIED           | YES     | YES   | YES   | ---   | ---     | YES  | ---   | ---
    RESTORED            | YES     | YES   | YES   | ---   | ---     | YES  | ---   | ---
    SUSPENDED           | ---     | ---   | ---   | YES   | YES     | YES  | ---   | TODO
    RESUMED             | ---     | ---   | ---   | YES   | YES     | YES  | ---   | TODO
    QUIT_REQUESTED      | YES     | YES   | YES   | ---   | ---     | ---  | TODO  | YES
    UPDATE_CURSOR       | YES     | YES   | TODO  | ---   | ---     | TODO | ---   | TODO
    IME                 | TODO    | TODO? | TODO  | ???   | TODO    | ---  | ???   | ???
    key repeat flag     | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    windowed            | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | YES
    fullscreen          | YES     | YES   | YES   | YES   | YES     | YES  | TODO  | ---
    mouse hide          | YES     | YES   | YES   | ---   | ---     | YES  | TODO  | TODO
    mouse lock          | YES     | YES   | YES   | ---   | ---     | TODO | TODO  | YES
    screen keyboard     | ---     | ---   | ---   | YES   | TODO    | TODO | ---   | YES
    swap interval       | YES     | YES   | YES   | YES   | TODO    | ---  | TODO  | YES
    high-dpi            | YES     | YES   | TODO  | YES   | YES     | YES  | TODO  | YES
    clipboard           | YES     | YES   | TODO  | ---   | ---     | TODO | ---   | YES
    MSAA                | YES     | YES   | YES   | YES   | YES     | TODO | TODO  | YES
    drag'n'drop         | YES     | YES   | YES   | ---   | ---     | TODO | TODO  | YES

    TODO
    ====
    - Linux:
        - clipboard support
    - UWP:
        - clipboard, mouselock
    - sapp_consume_event() on non-web platforms?
#end

'// enum
const SAPP_MAX_TOUCHPOINTS:int ' = 8
const SAPP_MAX_MOUSEBUTTONS:int ' = 3
const SAPP_MAX_KEYCODES:int ' = 512

enum sapp_event_type
end
const SAPP_EVENTTYPE_INVALID:sapp_event_type
const SAPP_EVENTTYPE_KEY_DOWN:sapp_event_type
const SAPP_EVENTTYPE_KEY_UP:sapp_event_type
const SAPP_EVENTTYPE_CHAR:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_DOWN:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_UP:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_SCROLL:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_MOVE:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_ENTER:sapp_event_type
const SAPP_EVENTTYPE_MOUSE_LEAVE:sapp_event_type
const SAPP_EVENTTYPE_TOUCHES_BEGAN:sapp_event_type
const SAPP_EVENTTYPE_TOUCHES_MOVED:sapp_event_type
const SAPP_EVENTTYPE_TOUCHES_ENDED:sapp_event_type
const SAPP_EVENTTYPE_TOUCHES_CANCELLED:sapp_event_type
const SAPP_EVENTTYPE_RESIZED:sapp_event_type
const SAPP_EVENTTYPE_ICONIFIED:sapp_event_type
const SAPP_EVENTTYPE_RESTORED:sapp_event_type
const SAPP_EVENTTYPE_SUSPENDED:sapp_event_type
const SAPP_EVENTTYPE_RESUMED:sapp_event_type
const SAPP_EVENTTYPE_UPDATE_CURSOR:sapp_event_type
const SAPP_EVENTTYPE_QUIT_REQUESTED:sapp_event_type
const SAPP_EVENTTYPE_CLIPBOARD_PASTED:sapp_event_type
const SAPP_EVENTTYPE_FILES_DROPPED:sapp_event_type
const _SAPP_EVENTTYPE_NUM:sapp_event_type
const _SAPP_EVENTTYPE_FORCE_U32:sapp_event_type

'/* key codes are the same names and values as GLFW */
enum sapp_keycode
end
const SAPP_KEYCODE_INVALID:sapp_keycode			'= 0,
const SAPP_KEYCODE_SPACE:sapp_keycode			'= 32,
const SAPP_KEYCODE_APOSTROPHE:sapp_keycode		'= 39,  /* ' */
const SAPP_KEYCODE_COMMA:sapp_keycode			'= 44,  /* , */
const SAPP_KEYCODE_MINUS:sapp_keycode			'= 45,  /* - */
const SAPP_KEYCODE_PERIOD:sapp_keycode			'= 46,  /* . */
const SAPP_KEYCODE_SLASH:sapp_keycode			'= 47,  /* / */
const SAPP_KEYCODE_0:sapp_keycode				'= 48,
const SAPP_KEYCODE_1:sapp_keycode				'= 49,
const SAPP_KEYCODE_2:sapp_keycode				'= 50,
const SAPP_KEYCODE_3:sapp_keycode				'= 51,
const SAPP_KEYCODE_4:sapp_keycode				'= 52,
const SAPP_KEYCODE_5:sapp_keycode				'= 53,
const SAPP_KEYCODE_6:sapp_keycode				'= 54,
const SAPP_KEYCODE_7:sapp_keycode				'= 55,
const SAPP_KEYCODE_8:sapp_keycode				'= 56,
const SAPP_KEYCODE_9:sapp_keycode				'= 57,
const SAPP_KEYCODE_SEMICOLON:sapp_keycode		'= 59,  /*  */
const SAPP_KEYCODE_EQUAL:sapp_keycode			'= 61,  /* = */
const SAPP_KEYCODE_A:sapp_keycode				'= 65,
const SAPP_KEYCODE_B:sapp_keycode				'= 66,
const SAPP_KEYCODE_C:sapp_keycode				'= 67,
const SAPP_KEYCODE_D:sapp_keycode				'= 68,
const SAPP_KEYCODE_E:sapp_keycode				'= 69,
const SAPP_KEYCODE_F:sapp_keycode				'= 70,
const SAPP_KEYCODE_G:sapp_keycode				'= 71,
const SAPP_KEYCODE_H:sapp_keycode				'= 72,
const SAPP_KEYCODE_I:sapp_keycode				'= 73,
const SAPP_KEYCODE_J:sapp_keycode				'= 74,
const SAPP_KEYCODE_K:sapp_keycode				'= 75,
const SAPP_KEYCODE_L:sapp_keycode				'= 76,
const SAPP_KEYCODE_M:sapp_keycode				'= 77,
const SAPP_KEYCODE_N:sapp_keycode				'= 78,
const SAPP_KEYCODE_O:sapp_keycode				'= 79,
const SAPP_KEYCODE_P:sapp_keycode				'= 80,
const SAPP_KEYCODE_Q:sapp_keycode				'= 81,
const SAPP_KEYCODE_R:sapp_keycode				'= 82,
const SAPP_KEYCODE_S:sapp_keycode				'= 83,
const SAPP_KEYCODE_T:sapp_keycode				'= 84,
const SAPP_KEYCODE_U:sapp_keycode				'= 85,
const SAPP_KEYCODE_V:sapp_keycode				'= 86,
const SAPP_KEYCODE_W:sapp_keycode				'= 87,
const SAPP_KEYCODE_X:sapp_keycode				'= 88,
const SAPP_KEYCODE_Y:sapp_keycode				'= 89,
const SAPP_KEYCODE_Z:sapp_keycode				'= 90,
const SAPP_KEYCODE_LEFT_BRACKET:sapp_keycode		'= 91,  /* [ */
const SAPP_KEYCODE_BACKSLASH:sapp_keycode		'= 92,  /* \ */
const SAPP_KEYCODE_RIGHT_BRACKET:sapp_keycode	'= 93,  /* ] */
const SAPP_KEYCODE_GRAVE_ACCENT:sapp_keycode		'= 96,  /* ` */
const SAPP_KEYCODE_WORLD_1:sapp_keycode			'= 161, /* non-US #1 */
const SAPP_KEYCODE_WORLD_2:sapp_keycode			'= 162, /* non-US #2 */
const SAPP_KEYCODE_ESCAPE:sapp_keycode			'= 256,
const SAPP_KEYCODE_ENTER:sapp_keycode			'= 257,
const SAPP_KEYCODE_TAB:sapp_keycode				'= 258,
const SAPP_KEYCODE_BACKSPACE:sapp_keycode		'= 259,
const SAPP_KEYCODE_INSERT:sapp_keycode			'= 260,
const SAPP_KEYCODE_DELETE:sapp_keycode			'= 261,
const SAPP_KEYCODE_RIGHT:sapp_keycode			'= 262,
const SAPP_KEYCODE_LEFT:sapp_keycode				'= 263,
const SAPP_KEYCODE_DOWN:sapp_keycode				'= 264,
const SAPP_KEYCODE_UP:sapp_keycode				'= 265,
const SAPP_KEYCODE_PAGE_UP:sapp_keycode			'= 266,
const SAPP_KEYCODE_PAGE_DOWN:sapp_keycode		'= 267,
const SAPP_KEYCODE_HOME:sapp_keycode				'= 268,
const SAPP_KEYCODE_END:sapp_keycode				'= 269,
const SAPP_KEYCODE_CAPS_LOCK:sapp_keycode		'= 280,
const SAPP_KEYCODE_SCROLL_LOCK:sapp_keycode		'= 281,
const SAPP_KEYCODE_NUM_LOCK:sapp_keycode			'= 282,
const SAPP_KEYCODE_PRINT_SCREEN:sapp_keycode		'= 283,
const SAPP_KEYCODE_PAUSE:sapp_keycode			'= 284,
const SAPP_KEYCODE_F1:sapp_keycode				'= 290,
const SAPP_KEYCODE_F2:sapp_keycode				'= 291,
const SAPP_KEYCODE_F3:sapp_keycode				'= 292,
const SAPP_KEYCODE_F4:sapp_keycode				'= 293,
const SAPP_KEYCODE_F5:sapp_keycode				'= 294,
const SAPP_KEYCODE_F6:sapp_keycode				'= 295,
const SAPP_KEYCODE_F7:sapp_keycode				'= 296,
const SAPP_KEYCODE_F8:sapp_keycode				'= 297,
const SAPP_KEYCODE_F9:sapp_keycode				'= 298,
const SAPP_KEYCODE_F10:sapp_keycode				'= 299,
const SAPP_KEYCODE_F11:sapp_keycode				'= 300,
const SAPP_KEYCODE_F12:sapp_keycode				'= 301,
const SAPP_KEYCODE_F13:sapp_keycode				'= 302,
const SAPP_KEYCODE_F14:sapp_keycode				'= 303,
const SAPP_KEYCODE_F15:sapp_keycode				'= 304,
const SAPP_KEYCODE_F16:sapp_keycode				'= 305,
const SAPP_KEYCODE_F17:sapp_keycode				'= 306,
const SAPP_KEYCODE_F18:sapp_keycode				'= 307,
const SAPP_KEYCODE_F19:sapp_keycode				'= 308,
const SAPP_KEYCODE_F20:sapp_keycode				'= 309,
const SAPP_KEYCODE_F21:sapp_keycode				'= 310,
const SAPP_KEYCODE_F22:sapp_keycode				'= 311,
const SAPP_KEYCODE_F23:sapp_keycode				'= 312,
const SAPP_KEYCODE_F24:sapp_keycode				'= 313,
const SAPP_KEYCODE_F25:sapp_keycode				'= 314,
const SAPP_KEYCODE_KP_0:sapp_keycode				'= 320,
const SAPP_KEYCODE_KP_1:sapp_keycode				'= 321,
const SAPP_KEYCODE_KP_2:sapp_keycode				'= 322,
const SAPP_KEYCODE_KP_3:sapp_keycode				'= 323,
const SAPP_KEYCODE_KP_4:sapp_keycode				'= 324,
const SAPP_KEYCODE_KP_5:sapp_keycode				'= 325,
const SAPP_KEYCODE_KP_6:sapp_keycode				'= 326,
const SAPP_KEYCODE_KP_7:sapp_keycode				'= 327,
const SAPP_KEYCODE_KP_8:sapp_keycode				'= 328,
const SAPP_KEYCODE_KP_9:sapp_keycode				'= 329,
const SAPP_KEYCODE_KP_DECIMAL:sapp_keycode		'= 330,
const SAPP_KEYCODE_KP_DIVIDE:sapp_keycode		'= 331,
const SAPP_KEYCODE_KP_MULTIPLY:sapp_keycode		'= 332,
const SAPP_KEYCODE_KP_SUBTRACT:sapp_keycode		'= 333,
const SAPP_KEYCODE_KP_ADD:sapp_keycode			'= 334,
const SAPP_KEYCODE_KP_ENTER:sapp_keycode			'= 335,
const SAPP_KEYCODE_KP_EQUAL:sapp_keycode			'= 336,
const SAPP_KEYCODE_LEFT_SHIFT:sapp_keycode		'= 340,
const SAPP_KEYCODE_LEFT_CONTROL:sapp_keycode		'= 341,
const SAPP_KEYCODE_LEFT_ALT:sapp_keycode			'= 342,
const SAPP_KEYCODE_LEFT_SUPER:sapp_keycode		'= 343,
const SAPP_KEYCODE_RIGHT_SHIFT:sapp_keycode		'= 344,
const SAPP_KEYCODE_RIGHT_CONTROL:sapp_keycode	'= 345,
const SAPP_KEYCODE_RIGHT_ALT:sapp_keycode		'= 346,
const SAPP_KEYCODE_RIGHT_SUPER:sapp_keycode		'= 347,
const SAPP_KEYCODE_MENU:sapp_keycode				'= 348,

struct sapp_touchpoint
	field identifier:ulong 'libc.uintptr_t
	field pos_x:float
	field pos_y:float
	field changed:bool
end

enum sapp_mousebutton
end
const SAPP_MOUSEBUTTON_LEFT:sapp_mousebutton
const SAPP_MOUSEBUTTON_RIGHT:sapp_mousebutton
const SAPP_MOUSEBUTTON_MIDDLE:sapp_mousebutton
const SAPP_MOUSEBUTTON_INVALID:sapp_mousebutton

'enum
const SAPP_MODIFIER_SHIFT:int '(1 << 0)
const SAPP_MODIFIER_CTRL:int '(1 << 1)
const SAPP_MODIFIER_ALT:int '(1 << 2)
const SAPP_MODIFIER_SUPER:int '(1 << 3)

struct sapp_event = "const sapp_event"
	field frame_count:ulong
	field type:sapp_event_type
	field key_code:sapp_keycode
	field char_code:uint
	field key_repeat:bool
	field modifiers:uint
    field mouse_button:sapp_mousebutton
	field mouse_x:float
	field mouse_y:float
	field mouse_dx:float
	field mouse_dy:float
	field scroll_x:float
	field scroll_y:float
	field num_touches:int
	field touches:sapp_touchpoint[] '[SAPP_MAX_TOUCHPOINTS]
	field window_width:int
	field window_height:int
	field framebuffer_width:int
	field framebuffer_height:int
end

struct sapp_desc
	'/* these are the user-provided callbacks without user data */
	field init_cb:void()
	field frame_cb:void()
	field cleanup_cb:void()
	field event_cb:void(sapp_event ptr)
	field fail_cb:void(const_char_t ptr)
	
	'/* these are the user-provided callbacks with user data */*
	field user_data:void ptr
	field init_userdata_cb:void(void ptr)
	field frame_userdata_cb:void(void ptr)
	field cleanup_userdata_cb:void(void ptr)
	field event_userdata_cb:void(sapp_event ptr, void ptr)
	field fail_userdata_cb:void(const_char_t ptr, void ptr)
	
	field width:int								'/* the preferred width of the window / canvas */
	field height:int							'/* the preferred height of the window / canvas */
	field sample_count:int						'/* MSAA sample count */
	field swap_interval:int						'/* the preferred swap interval (ignored on some platforms) */
	field high_dpi:bool							'/* whether the rendering canvas is full-resolution on HighDPI displays */
	field fullscreen:bool						'/* whether the window should be created in fullscreen mode */
	field alpha:bool							'/* whether the framebuffer should have an alpha channel (ignored on some platforms) */
	field window_title:const_char_t ptr	        '/* the window title as UTF-8 encoded string */
	field user_cursor:bool						'/* if true, user is expected to manage cursor image in SAPP_EVENTTYPE_UPDATE_CURSOR */
    field enable_clipboard:bool                 '/* enable clipboard access, default is false */
    field clipboard_size:int                    '/* max size of clipboard content in bytes */
    field enable_dragndrop:bool                 '/* enable file dropping (drag'n'drop), default is false */
    field max_dropped_files:int                 '/* max number of dropped files to process (default: 1) */
    field max_dropped_file_path_length:int      '/* max length in bytes of a dropped UTF-8 file path (default: 2048) */

	field html5_canvas_name:const_char_t ptr '/* the name (id) of the HTML5 canvas element, default is "canvas" */
	field html5_canvas_resize:bool				'/* if true, the HTML5 canvas size is set to sapp_desc.width/height, otherwise canvas size is tracked */
	field html5_preserve_drawing_buffer:bool	'/* HTML5 only: whether to preserve default framebuffer content between frames */
	field html5_premultiplied_alpha:bool		'/* HTML5 only: whether the rendered pixels use premultiplied alpha convention */
	field html5_ask_leave_site:bool				'/* initial state of the internal html5_ask_leave_site flag (see sapp_html5_ask_leave_site()) */
	field ios_keyboard_resizes_canvas:bool		'/* if true, showing the iOS keyboard shrinks the canvas */
	field gl_force_gles2:bool					'/* if true, setup GLES2/WebGL even if GLES3/WebGL2 is available */
end

'/* HTML5 specific: request and response structs for
'   asynchronously loading dropped-file content.
'*/
enum sapp_html5_fetch_error
end
const SAPP_HTML5_FETCH_ERROR_NO_ERROR:sapp_html5_fetch_error
const SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL:sapp_html5_fetch_error
const SAPP_HTML5_FETCH_ERROR_OTHER:sapp_html5_fetch_error

struct sapp_html5_fetch_response="const sapp_html5_fetch_response"
    field succeeded:bool        '/* true if the loading operation has succeeded */
    field error_code:sapp_html5_fetch_error
    field file_index:int        '/* index of the dropped file (0..sapp_get_num_dropped_filed()-1) */
    field fetched_size:uint     '/* size in bytes of loaded data */
    field buffer_ptr:void ptr   '/* pointer to user-provided buffer which contains the loaded data */
    field buffer_size:uint      '/* size of user-provided buffer (buffer_size >= fetched_size) */
    field user_data:void ptr    '/* user-provided user data pointer */
end

struct sapp_html5_fetch_request="const sapp_html5_fetch_request"
    field dropped_file_index:int                        '/* 0..sapp_get_num_dropped_files()-1 */
    field callback:void(sapp_html5_fetch_response ptr)  '/* response callback function pointer (required) */
    field buffer_ptr:void ptr                           '/* pointer to buffer to load data into */
    field buffer_size:uint                              '/* size in bytes of buffer */
    field user_data:void ptr                            '/* optional userdata pointer */
end

#rem wonkeydoc User-provided functions
#end
function sokol_main:sapp_desc(argc:int, argv:char_t ptr ptr)



#rem wonkeydoc Returns true after sokol-app has been initialized
#end
function sapp_isvalid:bool()
#rem wonkeydoc Returns the current framebuffer width in pixels
#end
function sapp_width:int()
#rem wonkeydoc returns the current framebuffer height in pixels
#end
function sapp_height:int()
#rem wonkeydoc get default framebuffer color pixel format
#end
function sapp_color_format:int()
#rem wonkeydoc  get default framebuffer depth pixel format
#end
function sapp_depth_format:int()
#rem wonkeydoc  get default framebuffer sample count
#end
function sapp_sample_count:int()
#rem wonkeydoc Returns true when high_dpi was requested and actually running in a high-dpi scenario
#end
function sapp_high_dpi:bool()
#rem wonkeydoc Returns the dpi scaling factor (window pixels to framebuffer pixels)
#end
function sapp_dpi_scale:float()
#rem wonkeydoc show or hide the mobile device onscreen keyboard
#end
function sapp_show_keyboard(visible:bool)
#rem wonkeydoc return true if the mobile device onscreen keyboard is currently shown
#end
function sapp_keyboard_shown:bool()
#rem wonkeydoc  query fullscreen mode
#end
function sapp_is_fullscreen:bool()
#rem wonkeydoc  toggle fullscreen mode
#end
function sapp_toggle_fullscreen:void()
#rem wonkeydoc show or hide the mouse cursor
#end
function sapp_show_mouse(visible:bool)
#rem wonkeydoc show or hide the mouse cursor
#end
function sapp_mouse_shown:bool()
#rem wonkeydoc enable/disable mouse-pointer-lock mode
#end
function sapp_lock_mouse(lock:bool)
#rem wonkeydoc return true if in mouse-pointer-lock mode (this may toggle a few frames later)
#end
function sapp_mouse_locked()
#rem wonkeydoc return the userdata pointer optionally provided in sapp_desc
#end
function sapp_userdata:void ptr()
#rem wonkeydoc return a copy of the sapp_desc structure
#end
function sapp_query_desc:sapp_desc()
#rem wonkeydoc initiate a "soft quit" (sends SAPP_EVENTTYPE_QUIT_REQUESTED)
#end
function sapp_request_quit()
#rem wonkeydoc cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received)
#end
function sapp_cancel_quit()
#rem wonkeydoc intiate a "hard quit" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUSTED)
#end
function sapp_quit()
#rem wonkeydoc call from inside event callback to consume the current event (don't forward to platform)
#end
function sapp_consume_event()
#rem wonkeydoc get the current frame counter (for comparison with sapp_event.frame_count)
#end
function sapp_frame_count:ulong()
#rem wonkeydoc write string into clipboard
#end
function sapp_set_clipboard_string(str:const_char_t ptr)
#rem wonkeydoc read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED)
#end
function sapp_get_clipboard_string:const_char_t ptr()
#rem wonkeydoc set the window title (only on desktop platforms)
#end
function sapp_set_window_title(str:const_char_t ptr)
#rem wonkeydoc gets the total number of dropped files (after an SAPP_EVENTTYPE_FILES_DROPPED event)
#end
function sapp_get_num_dropped_files:int()
#rem wonkeydoc gets the dropped file paths
#end
function sapp_get_dropped_file_path:const_char_t ptr(index:int)



#rem wonkeydoc special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub)
#end
function sapp_run:int(desc:sapp_desc ptr)



#rem wonkeydoc GL: return true when GLES2 fallback is active (to detect fallback from GLES3)
#end
function sapp_gles2:bool()



#rem wonkeydoc HTML5: enable or disable the hardwired "Leave Site?" dialog box
#end
function sapp_html5_ask_leave_site(ask:bool)
#rem wonkeydoc HTML5: get byte size of a dropped file
#end
function sapp_html5_get_dropped_file_size:uint(index:int)
#rem wonkeydoc HTML5: asynchronously load the content of a dropped file
#end
function sapp_html5_fetch_dropped_file(request:sapp_html5_fetch_request ptr)



#rem wonkeydoc Metal: get bridged pointer to Metal device object
#end
function sapp_metal_get_device:void ptr()
#rem wonkeydoc Metal: get bridged pointer to this frame's renderpass descriptor
#end
function sapp_metal_get_renderpass_descriptor:void ptr()
#rem wonkeydoc Metal: get bridged pointer to current drawable
#end
function sapp_metal_get_drawable:void ptr()
#rem wonkeydoc macOS: get bridged pointer to macOS NSWindow
#end
function sapp_macos_get_window:void ptr()
#rem wonkeydoc iOS: get bridged pointer to iOS UIWindow
#end
function sapp_ios_get_window:void ptr()



#rem wonkeydoc D3D11: get pointer to ID3D11Device object
#end
function sapp_d3d11_get_device:void ptr()
#rem wonkeydoc D3D11: get pointer to ID3D11DeviceContext object
#end
function sapp_d3d11_get_device_context:void ptr()
#rem wonkeydoc D3D11: get pointer to ID3D11RenderTargetView object
#end
function sapp_d3d11_get_render_target_view:void ptr()
#rem wonkeydoc D3D11: get pointer to ID3D11DepthStencilView
#end
function sapp_d3d11_get_depth_stencil_view:void ptr()
#rem wonkeydoc Win32: get the HWND window handle
#end
function sapp_win32_get_hwnd:void ptr()



#rem wonkeydoc WebGPU: get WGPUDevice handle
#end
function sapp_wgpu_get_device:void ptr()
#rem wonkeydoc WebGPU: get swapchain's WGPUTextureView handle for rendering
#end
function sapp_wgpu_get_render_view:void ptr()
#rem wonkeydoc WebGPU: get swapchain's MSAA-resolve WGPUTextureView (may return null)
#end
function sapp_wgpu_get_resolve_view:void ptr()
#rem wonkeydoc WebGPU: get swapchain's WGPUTextureView for the depth-stencil surface
#end
function sapp_wgpu_get_depth_stencil_view:void ptr()



#rem wonkeydoc Android: get native activity handle
#end
function sapp_android_get_native_activity:void ptr()

'//=================================================================================================================================
'//
'//
'// sokol_gfx.h
'//
'//
'//=================================================================================================================================

#rem
    sokol_gfx.h -- simple 3D API wrapper

    Project URL: https://github.com/floooh/sokol

    Do this:
        #define SOKOL_IMPL or
        #define SOKOL_GFX_IMPL
    before you include this file in *one* C or C++ file to create the
    implementation.

    In the same place define one of the following to select the rendering
    backend:
        #define SOKOL_GLCORE33
        #define SOKOL_GLES2
        #define SOKOL_GLES3
        #define SOKOL_D3D11
        #define SOKOL_METAL
        #define SOKOL_WGPU
        #define SOKOL_DUMMY_BACKEND

    I.e. for the GL 3.3 Core Profile it should look like this:

    #include ...
    #include ...
    #define SOKOL_IMPL
    #define SOKOL_GLCORE33
    #include "sokol_gfx.h"

    The dummy backend replaces the platform-specific backend code with empty
    stub functions. This is useful for writing tests that need to run on the
    command line.

    Optionally provide the following defines with your own implementations:

    SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))
    SOKOL_MALLOC(s)     - your own malloc function (default: malloc(s))
    SOKOL_FREE(p)       - your own free function (default: free(p))
    SOKOL_LOG(msg)      - your own logging function (default: puts(msg))
    SOKOL_UNREACHABLE() - a guard macro for unreachable code (default: assert(false))
    SOKOL_GFX_API_DECL  - public function declaration prefix (default: extern)
    SOKOL_API_DECL      - same as SOKOL_GFX_API_DECL
    SOKOL_API_IMPL      - public function implementation prefix (default: -)
    SOKOL_TRACE_HOOKS   - enable trace hook callbacks (search below for TRACE HOOKS)

    If sokol_gfx.h is compiled as a DLL, define the following before
    including the declaration or implementation:

    SOKOL_DLL

    On Windows, SOKOL_DLL will define SOKOL_GFX_API_DECL as __declspec(dllexport)
    or __declspec(dllimport) as needed.

    If you want to compile without deprecated structs and functions,
    define:

    SOKOL_NO_DEPRECATED

    Optionally define the following to force debug checks and validations
    even in release mode:

    SOKOL_DEBUG         - by default this is defined if _DEBUG is defined

    sokol_gfx DOES NOT:
    ===================
    - create a window or the 3D-API context/device, you must do this
      before sokol_gfx is initialized, and pass any required information
      (like 3D device pointers) to the sokol_gfx initialization call

    - present the rendered frame, how this is done exactly usually depends
      on how the window and 3D-API context/device was created

    - provide a unified shader language, instead 3D-API-specific shader
      source-code or shader-bytecode must be provided

    For complete code examples using the various backend 3D-APIs, see:

        https://github.com/floooh/sokol-samples

    For an optional shader-cross-compile solution, see:

        https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md
#end

'//-------------------------

#rem
    Resource id typedefs:

    sg_buffer:      vertex- and index-buffers
    sg_image:       textures and render targets
    sg_shader:      vertex- and fragment-shaders, uniform blocks
    sg_pipeline:    associated shader and vertex-layouts, and render states
    sg_pass:        a bundle of render targets and actions on them
    sg_context:     a 'context handle' for switching between 3D-API contexts

    Instead of pointers, resource creation functions return a 32-bit
    number which uniquely identifies the resource object.

    The 32-bit resource id is split into a 16-bit pool index in the lower bits,
    and a 16-bit 'unique counter' in the upper bits. The index allows fast
    pool lookups, and combined with the unique-mask it allows to detect
    'dangling accesses' (trying to use an object which no longer exists, and
    its pool slot has been reused for a new object)

    The resource ids are wrapped into a struct so that the compiler
    can complain when the wrong resource type is used.
#end
struct sg_buffer
end
struct sg_image
end
struct sg_shader
end
struct sg_pipeline
end
struct sg_pass
end
struct sg_context
end

#rem
    various compile-time constants

    FIXME: it may make sense to convert some of those into defines so
    that the user code can override them.
#end
const SG_INVALID_ID:int				'= 0,
const SG_NUM_SHADER_STAGES:int		'= 2,
const SG_NUM_INFLIGHT_FRAMES:int		'= 2,
const SG_MAX_COLOR_ATTACHMENTS:int	'= 4,
const SG_MAX_SHADERSTAGE_BUFFERS:int	'= 8,
const SG_MAX_SHADERSTAGE_IMAGES:int	'= 12,
const SG_MAX_SHADERSTAGE_UBS:int		'= 4,
const SG_MAX_UB_MEMBERS:int			'= 16,
const SG_MAX_VERTEX_ATTRIBUTES:int	'= 16,      /* NOTE: actual max vertex attrs can be less on GLES2, see sg_limits! */
const SG_MAX_MIPMAPS:int				'= 16,
const SG_MAX_TEXTUREARRAY_LAYERS:int	'= 128


#rem
    sg_backend

    The active 3D-API backend, use the function sg_query_backend()
    to get the currently active backend.

    For returned value corresponds with the compile-time define to select
    a backend, with the only exception of SOKOL_GLES3: this may
    return SG_BACKEND_GLES2 if the backend has to fallback to GLES2 mode
    because GLES3 isn't supported.
#end
enum sg_backend
end
const SG_BACKEND_GLCORE33:sg_backend
const SG_BACKEND_GLES2:sg_backend
const SG_BACKEND_GLES3:sg_backend
const SG_BACKEND_D3D11:sg_backend
const SG_BACKEND_METAL_IOS:sg_backend
const SG_BACKEND_METAL_MACOS:sg_backend
const SG_BACKEND_METAL_SIMULATOR:sg_backend
const SG_BACKEND_WGPU:sg_backend
const SG_BACKEND_DUMMY:sg_backend


#rem
    sg_pixel_format

    sokol_gfx.h basically uses the same pixel formats as WebGPU, since these
    are supported on most newer GPUs. GLES2 and WebGL has a much smaller
    subset of available pixel formats. Call sg_query_pixelformat() to check
    at runtime if a pixel format supports the desired features.

    A pixelformat name consist of three parts:

        - components (R, RG, RGB or RGBA)
        - bit width per component (8, 16 or 32)
        - component data type:
            - unsigned normalized (no postfix)
            - signed normalized (SN postfix)
            - unsigned integer (UI postfix)
            - signed integer (SI postfix)
            - float (F postfix)

    Not all pixel formats can be used for everything, call sg_query_pixelformat()
    to inspect the capabilities of a given pixelformat. The function returns
    an sg_pixelformat_info struct with the following bool members:

        - sample: the pixelformat can be sampled as texture at least with
                  nearest filtering
        - filter: the pixelformat can be samples as texture with linear
                  filtering
        - render: the pixelformat can be used for render targets
        - blend:  blending is supported when using the pixelformat for
                  render targets
        - msaa:   multisample-antiliasing is supported when using the
                  pixelformat for render targets
        - depth:  the pixelformat can be used for depth-stencil attachments

    When targeting GLES2/WebGL, the only safe formats to use
    as texture are SG_PIXELFORMAT_R8 and SG_PIXELFORMAT_RGBA8. For rendering
    in GLES2/WebGL, only SG_PIXELFORMAT_RGBA8 is safe. All other formats
    must be checked via sg_query_pixelformats().

    The default pixel format for texture images is SG_PIXELFORMAT_RGBA8.

    The default pixel format for render target images is platform-dependent:
        - for Metal and D3D11 it is SG_PIXELFORMAT_BGRA8
        - for GL backends it is SG_PIXELFORMAT_RGBA8

    This is mainly because of the default framebuffer which is setup outside
    of sokol_gfx.h. On some backends, using BGRA for the default frame buffer
    allows more efficient frame flips. For your own offscreen-render-targets,
    use whatever renderable pixel format is convenient for you.
#end
enum sg_pixel_format
end
const _SG_PIXELFORMAT_DEFAULT:sg_pixel_format	'/* value 0 reserved for default-init */
const SG_PIXELFORMAT_NONE:sg_pixel_format

const SG_PIXELFORMAT_R8:sg_pixel_format
const SG_PIXELFORMAT_R8SN:sg_pixel_format
const SG_PIXELFORMAT_R8UI:sg_pixel_format
const SG_PIXELFORMAT_R8SI:sg_pixel_format

const SG_PIXELFORMAT_R16:sg_pixel_format
const SG_PIXELFORMAT_R16SN:sg_pixel_format
const SG_PIXELFORMAT_R16UI:sg_pixel_format
const SG_PIXELFORMAT_R16SI:sg_pixel_format
const SG_PIXELFORMAT_R16F:sg_pixel_format
const SG_PIXELFORMAT_RG8:sg_pixel_format
const SG_PIXELFORMAT_RG8SN:sg_pixel_format
const SG_PIXELFORMAT_RG8UI:sg_pixel_format
const SG_PIXELFORMAT_RG8SI:sg_pixel_format

const SG_PIXELFORMAT_R32UI:sg_pixel_format
const SG_PIXELFORMAT_R32SI:sg_pixel_format
const SG_PIXELFORMAT_R32F:sg_pixel_format
const SG_PIXELFORMAT_RG16:sg_pixel_format
const SG_PIXELFORMAT_RG16SN:sg_pixel_format
const SG_PIXELFORMAT_RG16UI:sg_pixel_format
const SG_PIXELFORMAT_RG16SI:sg_pixel_format
const SG_PIXELFORMAT_RG16F:sg_pixel_format
const SG_PIXELFORMAT_RGBA8:sg_pixel_format
const SG_PIXELFORMAT_RGBA8SN:sg_pixel_format
const SG_PIXELFORMAT_RGBA8UI:sg_pixel_format
const SG_PIXELFORMAT_RGBA8SI:sg_pixel_format
const SG_PIXELFORMAT_BGRA8:sg_pixel_format
const SG_PIXELFORMAT_RGB10A2:sg_pixel_format
const SG_PIXELFORMAT_RG11B10F:sg_pixel_format

const SG_PIXELFORMAT_RG32UI:sg_pixel_format
const SG_PIXELFORMAT_RG32SI:sg_pixel_format
const SG_PIXELFORMAT_RG32F:sg_pixel_format
const SG_PIXELFORMAT_RGBA16:sg_pixel_format
const SG_PIXELFORMAT_RGBA16SN:sg_pixel_format
const SG_PIXELFORMAT_RGBA16UI:sg_pixel_format
const SG_PIXELFORMAT_RGBA16SI:sg_pixel_format
const SG_PIXELFORMAT_RGBA16F:sg_pixel_format

const SG_PIXELFORMAT_RGBA32UI:sg_pixel_format
const SG_PIXELFORMAT_RGBA32SI:sg_pixel_format
const SG_PIXELFORMAT_RGBA32F:sg_pixel_format

const SG_PIXELFORMAT_DEPTH:sg_pixel_format
const SG_PIXELFORMAT_DEPTH_STENCIL:sg_pixel_format

const SG_PIXELFORMAT_BC1_RGBA:sg_pixel_format
const SG_PIXELFORMAT_BC2_RGBA:sg_pixel_format
const SG_PIXELFORMAT_BC3_RGBA:sg_pixel_format
const SG_PIXELFORMAT_BC4_R:sg_pixel_format
const SG_PIXELFORMAT_BC4_RSN:sg_pixel_format
const SG_PIXELFORMAT_BC5_RG:sg_pixel_format
const SG_PIXELFORMAT_BC5_RGSN:sg_pixel_format
const SG_PIXELFORMAT_BC6H_RGBF:sg_pixel_format
const SG_PIXELFORMAT_BC6H_RGBUF:sg_pixel_format
const SG_PIXELFORMAT_BC7_RGBA:sg_pixel_format
const SG_PIXELFORMAT_PVRTC_RGB_2BPP:sg_pixel_format
const SG_PIXELFORMAT_PVRTC_RGB_4BPP:sg_pixel_format
const SG_PIXELFORMAT_PVRTC_RGBA_2BPP:sg_pixel_format
const SG_PIXELFORMAT_PVRTC_RGBA_4BPP:sg_pixel_format
const SG_PIXELFORMAT_ETC2_RGB8:sg_pixel_format
const SG_PIXELFORMAT_ETC2_RGB8A1:sg_pixel_format
const SG_PIXELFORMAT_ETC2_RGBA8:sg_pixel_format
const SG_PIXELFORMAT_ETC2_RG11:sg_pixel_format
const SG_PIXELFORMAT_ETC2_RG11SN:sg_pixel_format

const _SG_PIXELFORMAT_NUM:sg_pixel_format
const _SG_PIXELFORMAT_FORCE_U32:sg_pixel_format

#rem
	Runtime information about a pixel format, returned 
	by sg_query_pixelformat().
#end
struct sg_pixelformat_info
	field sample:bool	'/* pixel format can be sampled in shaders */
	field filter:bool	'/* pixel format can be sampled with filtering */
	field render:bool	'/* pixel format can be used as render target */
	field blend:bool	'/* alpha-blending is supported */
	field msaa:bool		'/* pixel format can be used as MSAA render target */
	field depth:bool	'/* pixel format is a depth format */
end

#rem 
	Runtime information about available optional features, 
	returned by sg_query_features().
#end
struct sg_features
	field instancing:bool               '/* hardware instancing supported */
	field origin_top_left:bool          '/* framebuffer and texture origin is in top left corner */
	field multiple_render_targets:bool  '/* offscreen render passes can have multiple render targets attached */
	field msaa_render_targets:bool      '/* offscreen render passes support MSAA antialiasing */
	field imagetype_3d:bool			    '/* creation of SG_IMAGETYPE_3D images is supported */
	field imagetype_array:bool		    '/* creation of SG_IMAGETYPE_ARRAY images is supported */
	field image_clamp_to_border:bool    '/* border color and clamp-to-border UV-wrap mode is supported */
end

#rem 
	Runtime information about resource limits, returned by sg_query_limit()
#end
struct sg_limits
	field max_image_size_2d:uint		'/* max width/height of SG_IMAGETYPE_2D images */
	field max_image_size_cube:uint		'/* max width/height of SG_IMAGETYPE_CUBE images */
	field max_image_size_3d:uint		'/* max width/height/depth of SG_IMAGETYPE_3D images */
	field max_image_size_array:uint     '/* max width/height of SG_IMAGETYPE_ARRAY images */
	field max_image_array_layers:uint   '/* max number of layers in SG_IMAGETYPE_ARRAY images */
	field max_vertex_attrs:uint			'/* <= SG_MAX_VERTEX_ATTRIBUTES (only on some GLES2 impls) */
end

#rem
    sg_resource_state

    The current state of a resource in its resource pool.
    Resources start in the INITIAL state, which means the
    pool slot is unoccupied and can be allocated. When a resource is
    created, first an id is allocated, and the resource pool slot
    is set to state ALLOC. After allocation, the resource is
    initialized, which may result in the VALID or FAILED state. The
    reason why allocation and initialization are separate is because
    some resource types (e.g. buffers and images) might be asynchronously
    initialized by the user application. If a resource which is not
    in the VALID state is attempted to be used for rendering, rendering
    operations will silently be dropped.

    The special INVALID state is returned in sg_query_xxx_state() if no
    resource object exists for the provided resource id.
#end
enum sg_resource_state
end
const SG_RESOURCESTATE_INITIAL:sg_resource_state
const SG_RESOURCESTATE_ALLOC:sg_resource_state
const SG_RESOURCESTATE_VALID:sg_resource_state
const SG_RESOURCESTATE_FAILED:sg_resource_state
const SG_RESOURCESTATE_INVALID:sg_resource_state
const _SG_RESOURCESTATE_FORCE_U32:sg_resource_state

#rem
    sg_usage

    A resource usage hint describing the update strategy of
    buffers and images. This is used in the sg_buffer_desc.usage
    and sg_image_desc.usage members when creating buffers
    and images:

    SG_USAGE_IMMUTABLE:     the resource will never be updated with
                            new data, instead the data content of the
                            resource must be provided on creation
    SG_USAGE_DYNAMIC:       the resource will be updated infrequently
                            with new data (this could range from "once
                            after creation", to "quite often but not
                            every frame")
    SG_USAGE_STREAM:        the resource will be updated each frame
                            with new content

    The rendering backends use this hint to prevent that the
    CPU needs to wait for the GPU when attempting to update
    a resource that might be currently accessed by the GPU.

    Resource content is updated with the function sg_update_buffer() for
    buffer objects, and sg_update_image() for image objects. Only
    one update is allowed per frame and resource object. The
    application must update all data required for rendering (this
    means that the update data can be smaller than the resource size,
    if only a part of the overall resource size is used for rendering,
    you only need to make sure that the data that *is* used is valid.

    The default usage is SG_USAGE_IMMUTABLE.
#end
enum sg_usage
end
const _SG_USAGE_DEFAULT:sg_usage		'/* value 0 reserved for default-init */
const SG_USAGE_IMMUTABLE:sg_usage
const SG_USAGE_DYNAMIC:sg_usage
const SG_USAGE_STREAM:sg_usage
const _SG_USAGE_NUM:sg_usage
const _SG_USAGE_FORCE_U32:sg_usage

#rem
    sg_buffer_type

    This indicates whether a buffer contains vertex- or index-data,
    used in the sg_buffer_desc.type member when creating a buffer.

    The default value is SG_BUFFERTYPE_VERTEXBUFFER.
#end
enum sg_buffer_type
end
const _SG_BUFFERTYPE_DEFAULT:sg_buffer_type			'/* value 0 reserved for default-init */
const SG_BUFFERTYPE_VERTEXBUFFER:sg_buffer_type
const SG_BUFFERTYPE_INDEXBUFFER:sg_buffer_type
const _SG_BUFFERTYPE_NUM:sg_buffer_type
const _SG_BUFFERTYPE_FORCE_U32:sg_buffer_type

#rem
    sg_index_type

    Indicates whether indexed rendering (fetching vertex-indices from an
    index buffer) is used, and if yes, the index data type (16- or 32-bits).
    This is used in the sg_pipeline_desc.index_type member when creating a
    pipeline object.

    The default index type is SG_INDEXTYPE_NONE.
#end
enum sg_index_type
end
const _SG_INDEXTYPE_DEFAULT:sg_index_type	'/* value 0 reserved for default-init */
const SG_INDEXTYPE_NONE:sg_index_type
const SG_INDEXTYPE_UINT16:sg_index_type
const SG_INDEXTYPE_UINT32:sg_index_type
const _SG_INDEXTYPE_NUM:sg_index_type
const _SG_INDEXTYPE_FORCE_U32:sg_index_type

#rem
    sg_image_type

    Indicates the basic image type (2D-texture, cubemap, 3D-texture
    or 2D-array-texture). 3D- and array-textures are not supported
    on the GLES2/WebGL backend. The image type is used in the
    sg_image_desc.type member when creating an image.

    The default image type when creating an image is SG_IMAGETYPE_2D.
#end
enum sg_image_type
end
const _SG_IMAGETYPE_DEFAULT:sg_image_type	'/* value 0 reserved for default-init */
const SG_IMAGETYPE_2D:sg_image_type
const SG_IMAGETYPE_CUBE:sg_image_type
const SG_IMAGETYPE_3D:sg_image_type
const SG_IMAGETYPE_ARRAY:sg_image_type
const _SG_IMAGETYPE_NUM:sg_image_type
const _SG_IMAGETYPE_FORCE_U32:sg_image_type

#rem
    sg_sampler_type

    Indicates the basic data type of a shader's texture sampler which
    can be float , unsigned integer or signed integer. The sampler
    type is used in the sg_shader_image_desc to describe the
    sampler type of a shader's texture sampler binding.

    The default sampler type is SG_SAMPLERTYPE_FLOAT.
#end
enum sg_sampler_type
end
const _SG_SAMPLERTYPE_DEFAULT:sg_sampler_type  '/* value 0 reserved for default-init */
const SG_SAMPLERTYPE_FLOAT:sg_sampler_type
const SG_SAMPLERTYPE_SINT:sg_sampler_type
const SG_SAMPLERTYPE_UINT:sg_sampler_type

#rem
    sg_cube_face

    The cubemap faces. Use these as indices in the sg_image_desc.content
    array.
#end
enum sg_cube_face
end
const SG_CUBEFACE_POS_X:sg_cube_face
const SG_CUBEFACE_NEG_X:sg_cube_face
const SG_CUBEFACE_POS_Y:sg_cube_face
const SG_CUBEFACE_NEG_Y:sg_cube_face
const SG_CUBEFACE_POS_Z:sg_cube_face
const SG_CUBEFACE_NEG_Z:sg_cube_face
const SG_CUBEFACE_NUM:sg_cube_face
const _SG_CUBEFACE_FORCE_U32:sg_cube_face

#rem
    sg_shader_stage

    There are 2 shader stages: vertex- and fragment-shader-stage.
    Each shader stage consists of:

    - one slot for a shader function (provided as source- or byte-code)
    - SG_MAX_SHADERSTAGE_UBS slots for uniform blocks
    - SG_MAX_SHADERSTAGE_IMAGES slots for images used as textures by
      the shader function
#end
enum sg_shader_stage
end
const SG_SHADERSTAGE_VS:sg_shader_stage
const SG_SHADERSTAGE_FS:sg_shader_stage
const _SG_SHADERSTAGE_FORCE_U32:sg_shader_stage

#rem
    sg_primitive_type

    This is the common subset of 3D primitive types supported across all 3D
    APIs. This is used in the sg_pipeline_desc.primitive_type member when
    creating a pipeline object.

    The default primitive type is SG_PRIMITIVETYPE_TRIANGLES.
#end
enum sg_primitive_type
end
const _SG_PRIMITIVETYPE_DEFAULT:sg_primitive_type	'/* value 0 reserved for default-init */
const SG_PRIMITIVETYPE_POINTS:sg_primitive_type
const SG_PRIMITIVETYPE_LINES:sg_primitive_type
const SG_PRIMITIVETYPE_LINE_STRIP:sg_primitive_type
const SG_PRIMITIVETYPE_TRIANGLES:sg_primitive_type
const SG_PRIMITIVETYPE_TRIANGLE_STRIP:sg_primitive_type
const _SG_PRIMITIVETYPE_NUM:sg_primitive_type
const _SG_PRIMITIVETYPE_FORCE_U32:sg_primitive_type

#rem
    sg_filter

    The filtering mode when sampling a texture image. This is
    used in the sg_image_desc.min_filter and sg_image_desc.mag_filter
    members when creating an image object.

    The default filter mode is SG_FILTER_NEAREST.
#end
enum sg_filter
end
const _SG_FILTER_DEFAULT:sg_filter '/* value 0 reserved for default-init */
const SG_FILTER_NEAREST:sg_filter
const SG_FILTER_LINEAR:sg_filter
const SG_FILTER_NEAREST_MIPMAP_NEAREST:sg_filter
const SG_FILTER_NEAREST_MIPMAP_LINEAR:sg_filter
const SG_FILTER_LINEAR_MIPMAP_NEAREST:sg_filter
const SG_FILTER_LINEAR_MIPMAP_LINEAR:sg_filter
const _SG_FILTER_NUM:sg_filter
const _SG_FILTER_FORCE_U32:sg_filter

#rem
    sg_wrap

    The texture coordinates wrapping mode when sampling a texture
    image. This is used in the sg_image_desc.wrap_u, .wrap_v
    and .wrap_w members when creating an image.

    The default wrap mode is SG_WRAP_REPEAT.

    NOTE: SG_WRAP_CLAMP_TO_BORDER is not supported on all backends
    and platforms. To check for support, call sg_query_features()
    and check the "clamp_to_border" boolean in the returned
    sg_features struct.

    Platforms which don't support SG_WRAP_CLAMP_TO_BORDER will silently fall back
    to SG_WRAP_CLAMP_TO_EDGE without a validation error.

    Platforms which support clamp-to-border are:

        - all desktop GL platforms
        - Metal on macOS
        - D3D11

    Platforms which do not support clamp-to-border:

        - GLES2/3 and WebGL/WebGL2
        - Metal on iOS
#end
enum sg_wrap
end
const _SG_WRAP_DEFAULT:sg_wrap	'/* value 0 reserved for default-init */
const SG_WRAP_REPEAT:sg_wrap
const SG_WRAP_CLAMP_TO_EDGE:sg_wrap
const SG_WRAP_CLAMP_TO_BORDER:sg_wrap
const SG_WRAP_MIRRORED_REPEAT:sg_wrap
const _SG_WRAP_NUM:sg_wrap
const _SG_WRAP_FORCE_U32:sg_wrap

#rem
    sg_border_color

    The border color to use when sampling a texture, and the UV wrap
    mode is SG_WRAP_CLAMP_TO_BORDER.

    The default border color is SG_BORDERCOLOR_OPAQUE_BLACK
#end
enum sg_border_color
end
const _SG_BORDERCOLOR_DEFAULT:sg_border_color	'/* value 0 reserved for default-init */
const SG_BORDERCOLOR_TRANSPARENT_BLACK:sg_border_color
const SG_BORDERCOLOR_OPAQUE_BLACK:sg_border_color
const SG_BORDERCOLOR_OPAQUE_WHITE:sg_border_color
const _SG_BORDERCOLOR_NUM:sg_border_color
const _SG_BORDERCOLOR_FORCE_U32:sg_border_color

#rem
    sg_vertex_format

    The data type of a vertex component. This is used to describe
    the layout of vertex data when creating a pipeline object.
#end
enum sg_vertex_format
end
const SG_VERTEXFORMAT_INVALID:sg_vertex_format
const SG_VERTEXFORMAT_FLOAT:sg_vertex_format
const SG_VERTEXFORMAT_FLOAT2:sg_vertex_format
const SG_VERTEXFORMAT_FLOAT3:sg_vertex_format
const SG_VERTEXFORMAT_FLOAT4:sg_vertex_format
const SG_VERTEXFORMAT_BYTE4:sg_vertex_format
const SG_VERTEXFORMAT_BYTE4N:sg_vertex_format
const SG_VERTEXFORMAT_UBYTE4:sg_vertex_format
const SG_VERTEXFORMAT_UBYTE4N:sg_vertex_format
const SG_VERTEXFORMAT_SHORT2:sg_vertex_format
const SG_VERTEXFORMAT_SHORT2N:sg_vertex_format
const SG_VERTEXFORMAT_USHORT2N:sg_vertex_format
const SG_VERTEXFORMAT_SHORT4:sg_vertex_format
const SG_VERTEXFORMAT_SHORT4N:sg_vertex_format
const SG_VERTEXFORMAT_USHORT4N:sg_vertex_format
const SG_VERTEXFORMAT_UINT10_N2:sg_vertex_format
const _SG_VERTEXFORMAT_NUM:sg_vertex_format
const _SG_VERTEXFORMAT_FORCE_U32:sg_vertex_format

#rem
    sg_vertex_step

    Defines whether the input pointer of a vertex input stream is advanced
    'per vertex' or 'per instance'. The default step-func is
    SG_VERTEXSTEP_PER_VERTEX. SG_VERTEXSTEP_PER_INSTANCE is used with
    instanced-rendering.

    The vertex-step is part of the vertex-layout definition
    when creating pipeline objects.
#end
enum sg_vertex_step
end
const _SG_VERTEXSTEP_DEFAULT:sg_vertex_step		'/* value 0 reserved for default-init */
const SG_VERTEXSTEP_PER_VERTEX:sg_vertex_step
const SG_VERTEXSTEP_PER_INSTANCE:sg_vertex_step
const _SG_VERTEXSTEP_NUM:sg_vertex_step
const _SG_VERTEXSTEP_FORCE_U32:sg_vertex_step

#rem
    sg_uniform_type

    The data type of a uniform block member. This is used to
    describe the internal layout of uniform blocks when creating
    a shader object.
#end
enum sg_uniform_type
end
const SG_UNIFORMTYPE_INVALID:sg_uniform_type
const SG_UNIFORMTYPE_FLOAT:sg_uniform_type
const SG_UNIFORMTYPE_FLOAT2:sg_uniform_type
const SG_UNIFORMTYPE_FLOAT3:sg_uniform_type
const SG_UNIFORMTYPE_FLOAT4:sg_uniform_type
const SG_UNIFORMTYPE_MAT4:sg_uniform_type
const _SG_UNIFORMTYPE_NUM:sg_uniform_type
const _SG_UNIFORMTYPE_FORCE_U32:sg_uniform_type

#rem
    sg_cull_mode

    The face-culling mode, this is used in the
    sg_pipeline_desc.rasterizer.cull_mode member when creating a
    pipeline object.

    The default cull mode is SG_CULLMODE_NONE
#end
enum sg_cull_mode
end
const _SG_CULLMODE_DEFAULT:sg_cull_mode	'/* value 0 reserved for default-init */
const SG_CULLMODE_NONE:sg_cull_mode
const SG_CULLMODE_FRONT:sg_cull_mode
const SG_CULLMODE_BACK:sg_cull_mode
const _SG_CULLMODE_NUM:sg_cull_mode
const _SG_CULLMODE_FORCE_U32:sg_cull_mode

#rem
    sg_face_winding

    The vertex-winding rule that determines a front-facing primitive. This
    is used in the member sg_pipeline_desc.rasterizer.face_winding
    when creating a pipeline object.

    The default winding is SG_FACEWINDING_CW (clockwise)
#end
enum sg_face_winding
end
const _SG_FACEWINDING_DEFAULT:sg_face_winding	'/* value 0 reserved for default-init */
const SG_FACEWINDING_CCW:sg_face_winding
const SG_FACEWINDING_CW:sg_face_winding
const _SG_FACEWINDING_NUM:sg_face_winding
const _SG_FACEWINDING_FORCE_U32:sg_face_winding

#rem
    sg_compare_func

    The compare-function for depth- and stencil-ref tests.
    This is used when creating pipeline objects in the members:

    sg_pipeline_desc
        .depth_stencil
            .depth_compare_func
            .stencil_front.compare_func
            .stencil_back.compare_func

    The default compare func for depth- and stencil-tests is
    SG_COMPAREFUNC_ALWAYS.
#end
enum sg_compare_func
end
const _SG_COMPAREFUNC_DEFAULT:sg_compare_func	'/* value 0 reserved for default-init */
const SG_COMPAREFUNC_NEVER:sg_compare_func
const SG_COMPAREFUNC_LESS:sg_compare_func
const SG_COMPAREFUNC_EQUAL:sg_compare_func
const SG_COMPAREFUNC_LESS_EQUAL:sg_compare_func
const SG_COMPAREFUNC_GREATER:sg_compare_func
const SG_COMPAREFUNC_NOT_EQUAL:sg_compare_func
const SG_COMPAREFUNC_GREATER_EQUAL:sg_compare_func
const SG_COMPAREFUNC_ALWAYS:sg_compare_func
const _SG_COMPAREFUNC_NUM:sg_compare_func
const _SG_COMPAREFUNC_FORCE_U32:sg_compare_func

#rem
    sg_stencil_op

    The operation performed on a currently stored stencil-value when a
    comparison test passes or fails. This is used when creating a pipeline
    object in the members:

    sg_pipeline_desc
        .depth_stencil
            .stencil_front
                .fail_op
                .depth_fail_op
                .pass_op
            .stencil_back
                .fail_op
                .depth_fail_op
                .pass_op

    The default value is SG_STENCILOP_KEEP.
#end
enum sg_stencil_op
end
const _SG_STENCILOP_DEFAULT:sg_stencil_op		'/* value 0 reserved for default-init */
const SG_STENCILOP_KEEP:sg_stencil_op
const SG_STENCILOP_ZERO:sg_stencil_op
const SG_STENCILOP_REPLACE:sg_stencil_op
const SG_STENCILOP_INCR_CLAMP:sg_stencil_op
const SG_STENCILOP_DECR_CLAMP:sg_stencil_op
const SG_STENCILOP_INVERT:sg_stencil_op
const SG_STENCILOP_INCR_WRAP:sg_stencil_op
const SG_STENCILOP_DECR_WRAP:sg_stencil_op
const _SG_STENCILOP_NUM:sg_stencil_op
const _SG_STENCILOP_FORCE_U32:sg_stencil_op

#rem
    sg_blend_factor

    The source and destination factors in blending operations.
    This is used in the following members when creating a pipeline object:

    sg_pipeline_desc
        .blend
            .src_factor_rgb
            .dst_factor_rgb
            .src_factor_alpha
            .dst_factor_alpha

    The default value is SG_BLENDFACTOR_ONE for source
    factors, and SG_BLENDFACTOR_ZERO for destination factors.
#end
enum sg_blend_factor
end
const _SG_BLENDFACTOR_DEFAULT:sg_blend_factor	'/* value 0 reserved for default-init */
const SG_BLENDFACTOR_ZERO:sg_blend_factor
const SG_BLENDFACTOR_ONE:sg_blend_factor
const SG_BLENDFACTOR_SRC_COLOR:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR:sg_blend_factor
const SG_BLENDFACTOR_SRC_ALPHA:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:sg_blend_factor
const SG_BLENDFACTOR_DST_COLOR:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_DST_COLOR:sg_blend_factor
const SG_BLENDFACTOR_DST_ALPHA:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA:sg_blend_factor
const SG_BLENDFACTOR_SRC_ALPHA_SATURATED:sg_blend_factor
const SG_BLENDFACTOR_BLEND_COLOR:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR:sg_blend_factor
const SG_BLENDFACTOR_BLEND_ALPHA:sg_blend_factor
const SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA:sg_blend_factor
const _SG_BLENDFACTOR_NUM:sg_blend_factor
const _SG_BLENDFACTOR_FORCE_U32:sg_blend_factor

#rem
    sg_blend_op

    Describes how the source and destination values are combined in the
    fragment blending operation. It is used in the following members when
    creating a pipeline object:

    sg_pipeline_desc
        .blend
            .op_rgb
            .op_alpha

    The default value is SG_BLENDOP_ADD.
#end
enum sg_blend_op
end
const _SG_BLENDOP_DEFAULT:sg_blend_op	'/* value 0 reserved for default-init */
const SG_BLENDOP_ADD:sg_blend_op
const SG_BLENDOP_SUBTRACT:sg_blend_op
const SG_BLENDOP_REVERSE_SUBTRACT:sg_blend_op
const _SG_BLENDOP_NUM:sg_blend_op
const _SG_BLENDOP_FORCE_U32:sg_blend_op

#rem
    sg_color_mask

    Selects the color channels when writing a fragment color to the
    framebuffer. This is used in the members
    sg_pipeline_desc.blend.color_write_mask when creating a pipeline object.

    The default colormask is SG_COLORMASK_RGBA (write all colors channels)
#end
enum sg_color_mask
end
const _SG_COLORMASK_DEFAULT:sg_color_mask ' = 0,      '/* value 0 reserved for default-init */
const SG_COLORMASK_NONE:sg_color_mask ' = (0x10),     '/* special value for 'all channels disabled */
const SG_COLORMASK_R:sg_color_mask ' = (1<<0),
const SG_COLORMASK_G:sg_color_mask ' = (1<<1),
const SG_COLORMASK_B:sg_color_mask ' = (1<<2),
const SG_COLORMASK_A:sg_color_mask ' = (1<<3),
const SG_COLORMASK_RGB:sg_color_mask ' = 0x7,
const SG_COLORMASK_RGBA:sg_color_mask ' = 0xF,
const _SG_COLORMASK_FORCE_U32:sg_color_mask ' = 0x7FFFFFFF

#rem
    sg_action

    Defines what action should be performed at the start of a render pass:

    SG_ACTION_CLEAR:    clear the render target image
    SG_ACTION_LOAD:     load the previous content of the render target image
    SG_ACTION_DONTCARE: leave the render target image content undefined

    This is used in the sg_pass_action structure.

    The default action for all pass attachments is SG_ACTION_CLEAR, with the
    clear color rgba = {0.5f, 0.5f, 0.5f, 1.0f], depth=1.0 and stencil=0.

    If you want to override the default behaviour, it is important to not
    only set the clear color, but the 'action' field as well (as long as this
    is in its _SG_ACTION_DEFAULT, the value fields will be ignored).
#end
enum sg_action
end
const _SG_ACTION_DEFAULT:sg_action
const SG_ACTION_CLEAR:sg_action
const SG_ACTION_LOAD:sg_action
const SG_ACTION_DONTCARE:sg_action
const _SG_ACTION_NUM:sg_action
const _SG_ACTION_FORCE_U32:sg_action

#rem
    sg_pass_action

    The sg_pass_action struct defines the actions to be performed
    at the start of a rendering pass in the functions sg_begin_pass()
    and sg_begin_default_pass().

    A separate action and clear values can be defined for each
    color attachment, and for the depth-stencil attachment.

    The default clear values are defined by the macros:

    - SG_DEFAULT_CLEAR_RED:     0.5f
    - SG_DEFAULT_CLEAR_GREEN:   0.5f
    - SG_DEFAULT_CLEAR_BLUE:    0.5f
    - SG_DEFAULT_CLEAR_ALPHA:   1.0f
    - SG_DEFAULT_CLEAR_DEPTH:   1.0f
    - SG_DEFAULT_CLEAR_STENCIL: 0
#end

'// struct: sg_color_attachment_action
struct sg_color_attachment_action
	field action:sg_action
	field val:float[]
end

'// struct: sg_depth_attachment_action
struct sg_depth_attachment_action
	field action:sg_action
	field val:float
end

'// struct: sg_stencil_attachment_action
struct sg_stencil_attachment_action
	field action:sg_action
	field val:ubyte
end

'// struct: sg_pass_action
struct sg_pass_action
	field _start_canary:uint
	
	field colors:sg_color_attachment_action[] '[SG_MAX_COLOR_ATTACHMENTS]
	field depth:sg_depth_attachment_action
	field stencil:sg_stencil_attachment_action
	
	field _end_canary:uint
end

#rem
    sg_bindings

    The sg_bindings structure defines the resource binding slots
    of the sokol_gfx render pipeline, used as argument to the
    sg_apply_bindings() function.

    A resource binding struct contains:

    - 1..N vertex buffers
    - 0..N vertex buffer offsets
    - 0..1 index buffers
    - 0..1 index buffer offsets
    - 0..N vertex shader stage images
    - 0..N fragment shader stage images

    The max number of vertex buffer and shader stage images
    are defined by the SG_MAX_SHADERSTAGE_BUFFERS and
    SG_MAX_SHADERSTAGE_IMAGES configuration constants.

    The optional buffer offsets can be used to group different chunks
    of vertex- and/or index-data into the same buffer objects.
#end
struct sg_bindings
	field _start_canary:uint
	
	field vertex_buffers:sg_buffer[] '[SG_MAX_SAHDERSTAGE_BUFFERS]
	field vertex_buffer_offsets:int[] '[SG_MAX_SAHDERSTAGE_BUFFERS]
	
	field index_buffer:sg_buffer
	field index_buffer_offset:int
	
	field vs_images:sg_image[] '[SG_MAX_SHADERSTAGE_IMAGES]
	field fs_images:sg_image[] '[SG_MAX_SHADERSTAGE_IMAGES]
	
	field _end_canary:uint
end

#rem
    sg_buffer_desc

    Creation parameters for sg_buffer objects, used in the
    sg_make_buffer() call.

    The default configuration is:

    .size:      0       (this *must* be set to a valid size in bytes)
    .type:      SG_BUFFERTYPE_VERTEXBUFFER
    .usage:     SG_USAGE_IMMUTABLE
    .content    0
    .label      0       (optional string label for trace hooks)

    The dbg_label will be ignored by sokol_gfx.h, it is only useful
    when hooking into sg_make_buffer() or sg_init_buffer() via
    the sg_install_trace_hook

    ADVANCED TOPIC: Injecting native 3D-API buffers:

    The following struct members allow to inject your own GL, Metal
    or D3D11 buffers into sokol_gfx:

    .gl_buffers[SG_NUM_INFLIGHT_FRAMES]
    .mtl_buffers[SG_NUM_INFLIGHT_FRAMES]
    .d3d11_buffer

    You must still provide all other members except the .content member, and
    these must match the creation parameters of the native buffers you
    provide. For SG_USAGE_IMMUTABLE, only provide a single native 3D-API
    buffer, otherwise you need to provide SG_NUM_INFLIGHT_FRAMES buffers
    (only for GL and Metal, not D3D11). Providing multiple buffers for GL and
    Metal is necessary because sokol_gfx will rotate through them when
    calling sg_update_buffer() to prevent lock-stalls.

    Note that it is expected that immutable injected buffer have already been
    initialized with content, and the .content member must be 0!

    Also you need to call sg_reset_state_cache() after calling native 3D-API
    functions, and before calling any sokol_gfx function.
#end
struct sg_buffer_desc
	field _start_canary:uint
	
	field size:int
	field type:sg_buffer_type
	field usage:sg_usage
	field content:void ptr
	field label:const_char_t ptr
	'/* GL specific */
	field gl_buffers:uint[] '[SG_NUM_INFLIGHT_FRAMES]
	'/* Metal specific */
	field mtl_buffers:void ptr[] '[SG_NUM_INFLIGHT_FRAMES]
	'/* D3D11 specific */
	field d3d11_buffer:void ptr
    '/* WebGPU specific */
    field wgpu_buffer:void ptr
	
	field _end_canary:uint
end

#rem
    sg_subimage_content

    Pointer to and size of a subimage-surface data, this is
    used to describe the initial content of immutable-usage images,
    or for updating a dynamic- or stream-usage images.

    For 3D- or array-textures, one sg_subimage_content item
    describes an entire mipmap level consisting of all array- or
    3D-slices of the mipmap level. It is only possible to update
    an entire mipmap level, not parts of it.
#end
struct sg_subimage_content
	field ptr_:void ptr="ptr"
	field size:int
end

#rem
    sg_image_content

    Defines the content of an image through a 2D array
    of sg_subimage_content structs. The first array dimension
    is the cubemap face, and the second array dimension the
    mipmap level.
#end
struct sg_image_content
	field subimage:sg_subimage_content[][] '[SG_CUBEFACE_NUM][SG_MAX_MIPMAPS]
end

#rem
    sg_image_desc

    Creation parameters for sg_image objects, used in the
    sg_make_image() call.

    The default configuration is:

    .type:              SG_IMAGETYPE_2D
    .render_target:     false
    .width              0 (must be set to >0)
    .height             0 (must be set to >0)
    .depth/.layers:     1
    .num_mipmaps:       1
    .usage:             SG_USAGE_IMMUTABLE
    .pixel_format:      SG_PIXELFORMAT_RGBA8 for textures, backend-dependent
                        for render targets (RGBA8 or BGRA8)
    .sample_count:      1 (only used in render_targets)
    .min_filter:        SG_FILTER_NEAREST
    .mag_filter:        SG_FILTER_NEAREST
    .wrap_u:            SG_WRAP_REPEAT
    .wrap_v:            SG_WRAP_REPEAT
    .wrap_w:            SG_WRAP_REPEAT (only SG_IMAGETYPE_3D)
    .border_color       SG_BORDERCOLOR_OPAQUE_BLACK
    .max_anisotropy     1 (must be 1..16)
    .min_lod            0.0f
    .max_lod            FLT_MAX
    .content            an sg_image_content struct to define the initial content
    .label              0       (optional string label for trace hooks)

    SG_IMAGETYPE_ARRAY and SG_IMAGETYPE_3D are not supported on
    WebGL/GLES2, use sg_query_features().imagetype_array and
    sg_query_features().imagetype_3d at runtime to check
    if array- and 3D-textures are supported.

    Images with usage SG_USAGE_IMMUTABLE must be fully initialized by
    providing a valid .content member which points to
    initialization data.

    ADVANCED TOPIC: Injecting native 3D-API textures:

    The following struct members allow to inject your own GL, Metal
    or D3D11 textures into sokol_gfx:

    .gl_textures[SG_NUM_INFLIGHT_FRAMES]
    .mtl_textures[SG_NUM_INFLIGHT_FRAMES]
    .d3d11_texture

    The same rules apply as for injecting native buffers
    (see sg_buffer_desc documentation for more details).
#end
struct sg_image_desc
	field _start_canary:uint
	
	field type:sg_image_type
	field render_target:bool
	
	field width:int
	field height:int

    field num_slices:int
	field num_mipmaps:int

	field usage:sg_usage
	field pixel_format:sg_pixel_format
	field sample_count:int
	
	field min_filter:sg_filter
	field mag_filter:sg_filter
	
	field wrap_u:sg_wrap
	field wrap_v:sg_wrap
	field wrap_w:sg_wrap
	
	field border_color:sg_border_color
	
	field max_anisotropy:uint
	
	field min_lod:float
	field max_lod:float
	
	field content:sg_image_content
	
	field label:const_char_t ptr
	
	'/* GL specific */
	field gl_textures:uint[] '[SG_NUM_INFLIGHT_FRAMES]
	'/* Metal specific */
	field mtl_textures:void ptr[] '[SG_NUM_INFLIGHT_FRAMES]
	'/* D3D11 specific */
	field d3d11_texture:void ptr
    field d3d11_shader_resource_view:void ptr
    '/* WebGPU specific */
    field wgpu_texture:void ptr
	
	field _end_canary:uint
end

#rem
    sg_shader_desc

    The structure sg_shader_desc defines all creation parameters
    for shader programs, used as input to the sg_make_shader() function:

    - reflection information for vertex attributes (vertex shader inputs):
        - vertex attribute name (required for GLES2, optional for GLES3 and GL)
        - a semantic name and index (required for D3D11)
    - for each vertex- and fragment-shader-stage:
        - the shader source or bytecode
        - an optional entry function name
        - reflection info for each uniform block used by the shader stage:
            - the size of the uniform block in bytes
            - reflection info for each uniform block member (only required for GL backends):
                - member name
                - member type (SG_UNIFORMTYPE_xxx)
                - if the member is an array, the number of array items
        - reflection info for the texture images used by the shader stage:
            - the image type (SG_IMAGETYPE_xxx)
            - the name of the texture sampler (required for GLES2, optional everywhere else)

    For all GL backends, shader source-code must be provided. For D3D11 and Metal,
    either shader source-code or byte-code can be provided.

    For D3D11, if source code is provided, the d3dcompiler_47.dll will be loaded
    on demand. If this fails, shader creation will fail.
#end

'// struct: sg_shader_attr_desc
struct sg_shader_attr_desc
	field name:const_char_t ptr			'/* GLSL vertex attribute name (only required for GLES2) */
	field sem_name:const_char_t ptr		'/* HLSL semantic name */
	field sem_index:int							'/* HLSL semantic index */
end

'// struct: sg_shader_uniform_desc
struct sg_shader_uniform_desc
	field name:const_char_t ptr
	field type:sg_uniform_type
	field array_count:int
end

'// struct: sg_shader_uniform_block_desc
struct sg_shader_uniform_block_desc
	field size:int
	field uniforms:sg_shader_uniform_desc[] '[SG_MAX_UB_MEMBERS]
end

'// struct: sg_shader_image_desc
struct sg_shader_image_desc
	field name:const_char_t ptr
	field type:sg_image_type
    field sampler_type:sg_sampler_type
end

'// struct: sg_shader_stage_desc
struct sg_shader_stage_desc
	field source:const_char_t ptr
	field byte_code:ubyte ptr
	field byte_code_size:int
	field entry:const_char_t ptr
	field d3d11_target:const_char_t ptr
	field uniform_blocks:sg_shader_uniform_block_desc[] '[SG_MAX_SHADERSTAGE_UBS]
	field images:sg_shader_image_desc[] '[SG_MAX_SHADERSTAGE_IMAGES]
end

'// struct: sg_shader_desc
struct sg_shader_desc
	field _start_canary:uint
	
	field attrs:sg_shader_attr_desc[] '[SG_MAX_VERTEX_ATTRIBUTES]
	field vs:sg_shader_stage_desc
	field fs:sg_shader_stage_desc
	field label:const_char_t ptr
	
	field _end_canary:uint
end

#rem
    sg_pipeline_desc

    The sg_pipeline_desc struct defines all creation parameters
    for an sg_pipeline object, used as argument to the
    sg_make_pipeline() function:

    - the vertex layout for all input vertex buffers
    - a shader object
    - the 3D primitive type (points, lines, triangles, ...)
    - the index type (none, 16- or 32-bit)
    - depth-stencil state
    - alpha-blending state
    - rasterizer state

    If the vertex data has no gaps between vertex components, you can omit
    the .layout.buffers[].stride and layout.attrs[].offset items (leave them
    default-initialized to 0), sokol will then compute the offsets and strides
    from the vertex component formats (.layout.attrs[].offset). Please note
    that ALL vertex attribute offsets must be 0 in order for the the
    automatic offset computation to kick in.

    The default configuration is as follows:

    .layout:
        .buffers[]:         vertex buffer layouts
            .stride:        0 (if no stride is given it will be computed)
            .step_func      SG_VERTEXSTEP_PER_VERTEX
            .step_rate      1
        .attrs[]:           vertex attribute declarations
            .buffer_index   0 the vertex buffer bind slot
            .offset         0 (offsets can be omitted if the vertex layout has no gaps)
            .format         SG_VERTEXFORMAT_INVALID (must be initialized!)
    .shader:            0 (must be intilized with a valid sg_shader id!)
    .primitive_type:    SG_PRIMITIVETYPE_TRIANGLES
    .index_type:        SG_INDEXTYPE_NONE
    .depth_stencil:
        .stencil_front, .stencil_back:
            .fail_op:               SG_STENCILOP_KEEP
            .depth_fail_op:         SG_STENCILOP_KEEP
            .pass_op:               SG_STENCILOP_KEEP
            .compare_func           SG_COMPAREFUNC_ALWAYS
        .depth_compare_func:    SG_COMPAREFUNC_ALWAYS
        .depth_write_enabled:   false
        .stencil_enabled:       false
        .stencil_read_mask:     0
        .stencil_write_mask:    0
        .stencil_ref:           0
    .blend:
        .enabled:               false
        .src_factor_rgb:        SG_BLENDFACTOR_ONE
        .dst_factor_rgb:        SG_BLENDFACTOR_ZERO
        .op_rgb:                SG_BLENDOP_ADD
        .src_factor_alpha:      SG_BLENDFACTOR_ONE
        .dst_factor_alpha:      SG_BLENDFACTOR_ZERO
        .op_alpha:              SG_BLENDOP_ADD
        .color_write_mask:      SG_COLORMASK_RGBA
        .color_attachment_count 1
        .color_format           SG_PIXELFORMAT_RGBA8
        .depth_format           SG_PIXELFORMAT_DEPTHSTENCIL
        .blend_color:           { 0.0f, 0.0f, 0.0f, 0.0f }
    .rasterizer:
        .alpha_to_coverage_enabled:     false
        .cull_mode:                     SG_CULLMODE_NONE
        .face_winding:                  SG_FACEWINDING_CW
        .sample_count:                  1
        .depth_bias:                    0.0f
        .depth_bias_slope_scale:        0.0f
        .depth_bias_clamp:              0.0f
    .label  0       (optional string label for trace hooks)
#end

'// struct: sg_buffer_layout_desc
struct sg_buffer_layout_desc
	field stride:int
	field step_func:sg_vertex_step
	field step_rate:int
end

'// struct: sg_vertex_attr_desc
struct sg_vertex_attr_desc
	field buffer_index:int
	field offset:int
	field format:sg_vertex_format
end

'// struct: sg_layout_desc
struct sg_layout_desc
	field buffers:sg_buffer_layout_desc[] '[SG_MAX_SHADERSTAGE_BUFFERS]
	field attrs:sg_vertex_attr_desc[] '[SG_MAX_VERTEX_ATTRIBUTES]
end

'// struct: sg_stencil_state
struct sg_stencil_state
	field fail_op:sg_stencil_op
	field depth_fail_op:sg_stencil_op
	field pass_op:sg_stencil_op
	field compare_func:sg_compare_func
end

'// struct: sg_depth_stencil_state
struct sg_depth_stencil_state
	field stencil_front:sg_stencil_state
	field stencil_back:sg_stencil_state
	field depth_compare_func:sg_compare_func
	field depth_write_enabled:bool
	field stencil_enabled:bool
	field stencil_read_mask:ubyte
	field stencil_write_mask:ubyte
	field stencil_ref:ubyte
end

'// struct: sg_blend_state
struct sg_blend_state
	field enabled:bool
	
	field src_factor_rgb:sg_blend_factor
	field dst_factor_rgb:sg_blend_factor
	field op_rgb:sg_blend_op
	
	field src_factor_alpha:sg_blend_factor
	field dst_factor_alpha:sg_blend_factor
	field op_alpha:sg_blend_op
	
	field color_write_mask:ubyte
	field color_attachment_count:int
	
	field color_format:sg_pixel_format
	field depth_format:sg_pixel_format
	
	field blend_color:float[] 'size=4
end

'// struct: sg_rasterizer_state
struct sg_rasterizer_state
	field alpha_to_coverage_enabled:bool
	field cull_mode:sg_cull_mode
	field face_winding:sg_face_winding
	field sample_count:int
	field depth_bias:float
	field depth_bias_slope_scale:float
	field depth_bias_clamp:float
end

'// struct: sg_pipeline_desc
struct sg_pipeline_desc
	field _start_canary:uint
	
	field layout:sg_layout_desc
	field shader:sg_shader
	field primitive_type:sg_primitive_type
	field index_type:sg_index_type
	field depth_stencil:sg_depth_stencil_state
	field blend:sg_blend_state
	field rasterizer:sg_rasterizer_state
	field label:const_char_t ptr
	
	field _end_canary:uint
end

#rem
    sg_pass_desc

    Creation parameters for an sg_pass object, used as argument
    to the sg_make_pass() function.

    A pass object contains 1..4 color-attachments and none, or one,
    depth-stencil-attachment. Each attachment consists of
    an image, and two additional indices describing
    which subimage the pass will render: one mipmap index, and
    if the image is a cubemap, array-texture or 3D-texture, the
    face-index, array-layer or depth-slice.

    Pass images must fulfill the following requirements:

    All images must have:
    - been created as render target (sg_image_desc.render_target = true)
    - the same size
    - the same sample count

    In addition, all color-attachment images must have the same
    pixel format.
#end

'// struct: sg_attachment_desc
struct sg_attachment_desc
	field image:sg_image
	field mip_level:int
	field u_face_layer_slice:int ' union { int face, layer, slice }
end

'// struct: sg_pass_desc
struct sg_pass_desc
	field _start_canary:uint
	
	field color_attachments:sg_attachment_desc[] '[SG_MAX_COLOR_ATTACHMENTS]
	field depth_stencil_attachment:sg_attachment_desc
	field label:const_char_t ptr
	
	field _end_canary:uint
end

#rem
    sg_trace_hooks

    Installable callback functions to keep track of the sokol_gfx calls,
    this is useful for debugging, or keeping track of resource creation
    and destruction.

    Trace hooks are installed with sg_install_trace_hooks(), this returns
    another sg_trace_hooks struct with the previous set of
    trace hook function pointers. These should be invoked by the
    new trace hooks to form a proper call chain.
#end

'// struct: sg_trace_hooks
struct sg_trace_hooks
	field user_data:void ptr
	field reset_state_cache:void(user_data:void ptr)
	field make_buffer:void(desc:sg_buffer_desc ptr, result:sg_buffer, user_data:void ptr)
	field make_image:void(desc:sg_image_desc ptr, result:sg_image, user_data:void ptr)
	field make_shader:void(desc:sg_shader_desc ptr, result:sg_shader, user_data:void ptr)
	field make_pipeline:void(desc:sg_pipeline_desc ptr, result:sg_pipeline, user_data:void ptr)
	field make_pass:void(desc:sg_pass_desc ptr, result:sg_pass, user_data:void ptr)
	field destroy_buffer:void(buf:sg_buffer, user_data:void ptr)
	field destroy_image:void(img:sg_image, user_data:void ptr)
	field destroy_shader:void(shd:sg_shader, user_data:void ptr)
	field destroy_pipeline:void(pip:sg_pipeline, user_data:void ptr)
	field destroy_pass:void(pass:sg_pass, user_data:void ptr)
	field update_buffer:void(buf:sg_buffer, data_ptr:void ptr, data_size:int, user_data:void ptr)
	field update_image:void(img:sg_image, data:sg_image_content ptr, user_data:void ptr)
	field append_buffer:void(buf:sg_buffer, data_ptr:void ptr, data_size:int, result:int, user_data:void ptr)
	field begin_default_pass:void(pass_action:sg_pass_action ptr, width:int, height:int, user_data:void ptr)
	field begin_pass:void(pass:sg_pass, pass_action:sg_pass_action ptr, user_data:void ptr)
	field apply_viewport:void(x:int, y:int, width:int, height:int, origin_top_left:bool, user_data:void ptr)
	field apply_scissor_rect:void(x:int, y:int, width:int, height:int, origin_top_left:bool, user_data:void ptr)
	field apply_pipeline:void(pip:sg_pipeline, user_data:void ptr)
	field apply_bindings:void(bindings:sg_bindings ptr, user_data:void ptr)
	field apply_uniforms:void(stage:sg_shader_stage, ub_index:int, data:void ptr, num_bytes:int, user_data:void ptr)
	field draw:void(base_element:int, num_elements:int, num_instances:int, user_data:void ptr)
	field end_pass:void(user_data:void ptr)
	field commit:void(user_data:void ptr)
	field alloc_buffer:void(result:sg_buffer, user_data:void ptr)
	field alloc_image:void(result:sg_image, user_data:void ptr)
	field alloc_shader:void(result:sg_shader, user_data:void ptr)
	field alloc_pipeline:void(result:sg_pipeline, user_data:void ptr)
	field alloc_pass:void(result:sg_pass, user_data:void ptr)
    field dealloc_buffer:void(buf_id:sg_buffer, user_data:void ptr)
    field dealloc_image:void(img_id:sg_image, user_data:void ptr)
    field dealloc_shader:void(shd_id:sg_shader, user_data:void ptr)
    field dealloc_pipeline:void(pip_id:sg_pipeline, user_data:void ptr)
    field dealloc_pass:void(pass_id:sg_pass, user_data:void ptr)
	field init_buffer:void(buf_id:sg_buffer, desc:sg_buffer_desc ptr, user_data:void ptr)
	field init_image:void(img_id:sg_image, desc:sg_image_desc ptr, user_data:void ptr)
	field init_shader:void(shd_id:sg_shader, desc:sg_shader_desc ptr, user_data:void ptr)
	field init_pipeline:void(pip_id:sg_pipeline, desc:sg_pipeline_desc ptr, user_data:void ptr)
	field init_pass:void(pass_id:sg_pass, desc:sg_pass_desc ptr, user_data:void ptr)
    field uninit_buffer:void(buf_id:sg_buffer, user_data:void ptr)
    field uninit_image:void(img_id:sg_image, user_data:void ptr)
    field uninit_shader:void(shd_id:sg_shader, user_data:void ptr)
    field uninit_pipeline:void(pip_id:sg_pipeline, user_data:void ptr)
    field uninit_pass:void(pass_id:sg_pass, user_data:void ptr)
	field fail_buffer:void(buf_id:sg_buffer, user_data:void ptr)
	field fail_image:void(img_id:sg_image, user_data:void ptr)
	field fail_shader:void(shd_id:sg_shader, user_data:void ptr)
	field fail_pipeline:void(pip_id:sg_pipeline, user_data:void ptr)
	field fail_pass:void(pass_id:sg_pass, user_data:void ptr)
	field push_debug_group:void(name:const_char_t ptr, user_data:void ptr)
	field pop_debug_group:void(user_data:void ptr)
	field err_buffer_pool_exhausted:void(user_data:void ptr)
	field err_image_pool_exhausted:void(user_data:void ptr)
	field err_shader_pool_exhausted:void(user_data:void ptr)
	field err_pipeline_pool_exhausted:void(user_data:void ptr)
	field err_pass_pool_exhausted:void(user_data:void ptr)
	field err_context_mismatch:void(user_data:void ptr)
	field err_pass_invalid:void(user_data:void ptr)
	field err_draw_invalid:void(user_data:void ptr)
	field err_bindings_invalid:void(user_data:void ptr)
end

#rem
    sg_buffer_info
    sg_image_info
    sg_shader_info
    sg_pipeline_info
    sg_pass_info

    These structs contain various internal resource attributes which
    might be useful for debug-inspection. Please don't rely on the
    actual content of those structs too much, as they are quite closely
    tied to sokol_gfx.h internals and may change more frequently than
    the other public API elements.

    The *_info structs are used as the return values of the following functions:

    sg_query_buffer_info()
    sg_query_image_info()
    sg_query_shader_info()
    sg_query_pipeline_info()
    sg_query_pass_info()
#end

'// struct: sg_slot_info
struct sg_slot_info
	field state:sg_resource_state	'/* the current state of this resource slot */
	field res_id:uint				'/* type-neutral resource if (e.g. sg_buffer.id) */
	field ctx_id:uint				'/* the context this resource belongs to */
end

'// struct: sg_buffer_info
struct sg_buffer_info
	field slot:sg_slot_info				'/* resource pool slot info */
	field update_frame_index:uint		'/* frame index of last sg_update_buffer() */
	field append_frame_index:uint		'/* frame index of last sg_append_buffer() */
	field append_pos:int				'/* current position in buffer for sg_append_buffer() */
	field append_overflow:bool			'/* is buffer in overflow state (due to sg_append_buffer) */
	field num_slots:int					'/* number of renaming-slots for dynamically updated buffers */
	field active_slot:int				'/* currently active write-slot for dynamically updated buffers */
end

'// struct: sg_image_info
struct sg_image_info
	field slot:sg_slot_info				'/* resource pool slot info */
	field upd_frame_index:uint			'/* frame index of last sg_update_image() */
	field num_slots:int					'/* number of renaming-slots for dynamically updated images */
	field active_slot:int				'/* currently active write-slot for dynamically updated images */
    field width:int                     '/* image width */
    field height:int                    '/* image height */
end

'// struct: sg_shader_info
struct sg_shader_info
	field slot:sg_slot_info				'/* resoure pool slot info */
end

'// struct: sg_pipeline_info
struct sg_pipeline_info
	field slot:sg_slot_info				'/* resource pool slot info */
end

'// struct: sg_pass_info
struct sg_pass_info
	field slot:sg_slot_info				'/* resource pool slot info */
end

#rem
    sg_desc

    The sg_desc struct contains configuration values for sokol_gfx,
    it is used as parameter to the sg_setup() call.

    NOTE that all callback function pointers come in two versions, one without
    a userdata pointer, and one with a userdata pointer. You would
    either initialize one or the other depending on whether you pass data
    to your callbacks.

    FIXME: explain the various configuration options

    The default configuration is:

    .buffer_pool_size       128
    .image_pool_size        128
    .shader_pool_size       32
    .pipeline_pool_size     64
    .pass_pool_size         16
    .context_pool_size      16
    .sampler_cache_size     64
    .uniform_buffer_size    4 MB (4*1024*1024)
    .staging_buffer_size    8 MB (8*1024*1024)

    .context.color_format: default value depends on selected backend:
        all GL backends:    SG_PIXELFORMAT_RGBA8
        Metal and D3D11:    SG_PIXELFORMAT_BGRA8
        WGPU:               *no default* (must be queried from WGPU swapchain)
    .context.depth_format   SG_PIXELFORMAT_DEPTH_STENCIL
    .context.sample_count   1

    GL specific:
        .context.gl.force_gles2
            if this is true the GL backend will act in "GLES2 fallback mode" even
            when compiled with SOKOL_GLES3, this is useful to fall back
            to traditional WebGL if a browser doesn't support a WebGL2 context

    Metal specific:
        (NOTE: All Objective-C object references are transferred through
        a bridged (const void*) to sokol_gfx, which will use a unretained
        bridged cast (__bridged id<xxx>) to retrieve the Objective-C
        references back. Since the bridge cast is unretained, the caller
        must hold a strong reference to the Objective-C object for the
        duration of the sokol_gfx call!

        .context.metal.device
            a pointer to the MTLDevice object
        .context.metal.renderpass_descriptor_cb
        .context.metal_renderpass_descriptor_userdata_cb
            A C callback function to obtain the MTLRenderPassDescriptor for the
            current frame when rendering to the default framebuffer, will be called
            in sg_begin_default_pass().
        .context.metal.drawable_cb
        .context.metal.drawable_userdata_cb
            a C callback function to obtain a MTLDrawable for the current
            frame when rendering to the default framebuffer, will be called in
            sg_end_pass() of the default pass
        .context.metal.user_data
            optional user data pointer passed to the userdata versions of
            callback functions

    D3D11 specific:
        .context.d3d11.device
            a pointer to the ID3D11Device object, this must have been created
            before sg_setup() is called
        .context.d3d11.device_context
            a pointer to the ID3D11DeviceContext object
        .context.d3d11.render_target_view_cb
        .context.d3d11.render_target_view_userdata_cb
            a C callback function to obtain a pointer to the current
            ID3D11RenderTargetView object of the default framebuffer,
            this function will be called in sg_begin_pass() when rendering
            to the default framebuffer
        .context.d3d11.depth_stencil_view_cb
        .context.d3d11.depth_stencil_view_userdata_cb
            a C callback function to obtain a pointer to the current
            ID3D11DepthStencilView object of the default framebuffer,
            this function will be called in sg_begin_pass() when rendering
            to the default framebuffer
        .context.metal.user_data
            optional user data pointer passed to the userdata versions of
            callback functions

    WebGPU specific:
        .context.wgpu.device
            a WGPUDevice handle
        .context.wgpu.render_format
            WGPUTextureFormat of the swap chain surface
        .context.wgpu.render_view_cb
        .context.wgpu.render_view_userdata_cb
            callback to get the current WGPUTextureView of the swapchain's
            rendering attachment (may be an MSAA surface)
        .context.wgpu.resolve_view_cb
        .context.wgpu.resolve_view_userdata_cb
            callback to get the current WGPUTextureView of the swapchain's
            MSAA-resolve-target surface, must return 0 if not MSAA rendering
        .context.wgpu.depth_stencil_view_cb
        .context.wgpu.depth_stencil_view_userdata_cb
            callback to get current default-pass depth-stencil-surface WGPUTextureView
            the pixel format of the default WGPUTextureView must be WGPUTextureFormat_Depth24Plus8
        .context.metal.user_data
            optional user data pointer passed to the userdata versions of
            callback functions

    When using sokol_gfx.h and sokol_app.h together, consider using the
    helper function sapp_sgcontext() in the sokol_glue.h header to
    initialize the sg_desc.context nested struct. sapp_sgcontext() returns
    a completely initialized sg_context_desc struct with information
    provided by sokol_app.h.
#end
struct sg_gl_context_desc
    field force_gles2:bool
end

struct sg_metal_context_desc
    field device:void ptr
    field renderpass_descriptor_cb:void()
    field renderpass_descriptor_userdata_cb:void()
    field drawable_cb:void()
    field drawable_userdata_cb:void()
    field user_data:void ptr
end

struct sg_d3d11_context_desc
    field device:void ptr
    field device_context:void ptr
    field render_target_view_cb:void()
    field render_target_view_userdata_cb:void(void ptr)
    field depth_stencil_view_cb:void()
    field depth_stencil_view_userdata_cb:void(void ptr)
    field user_data:void ptr
end

struct sg_wgpu_context_desc
    field device:void ptr
    field render_view_cb:void()
    field render_view_userdata_cb:void(void ptr)
    field resolve_view_cb:void()
    field resolve_view_userdata_cb:void(void ptr)
    field depth_stencil_view_cb:void()
    field depth_stencil_view_userdata_cb:void(void ptr)
    field user_data:void ptr
end

struct sg_context_desc
    field color_format:sg_pixel_format
    field depth_format:sg_pixel_format
    field sample_count:int
    field gl:sg_gl_context_desc
    field metal:sg_metal_context_desc
    field d3d11:sg_d3d11_context_desc
    field wgpu:sg_wgpu_context_desc
end

struct sg_desc
	field _start_canary:uint
	
	field buffer_pool_size:int
	field image_pool_size:int
	field shader_pool_size:int
	field pipeline_pool_size:int
	field pass_pool_size:int
	field context_pool_size:int
    field uniform_buffer_size:int
    field staging_buffer_size:int
	field sampler_cache_size:int
    field context:sg_context_desc

	field _end_canary:uint
end

'//-------- Functions

'/* setup and misc functions  */
function sg_setup:void(desc:sg_desc ptr)
function sg_shutdown:void()
function sg_isvalid:bool()
function sg_reset_state_cache:void()
function sg_install_trace_hooks:sg_trace_hooks(trace_hooks:sg_trace_hooks ptr)
function sg_push_debug_group:void(name:const_char_t ptr)
function sg_pop_debug_group:void()

'/* resource creation, destruction and updating  */
function sg_make_buffer:sg_buffer(desc:sg_buffer_desc ptr)
function sg_make_image:sg_image(desc:sg_image_desc ptr)
function sg_make_shader:sg_shader(desc:sg_shader_desc ptr)
function sg_make_pipeline:sg_pipeline(desc:sg_pipeline_desc ptr)
function sg_make_pass:sg_pass(desc:sg_pass_desc ptr)
function sg_destroy_buffer:void(buf:sg_buffer)
function sg_destroy_image:void(img:sg_image)
function sg_destroy_shader:void(shd:sg_shader)
function sg_destroy_pipeline:void(pip:sg_pipeline)
function sg_destroy_pass:void(pass:sg_pass)
function sg_update_buffer:void(buf:sg_buffer, data_ptr:void ptr, data_size:int)
function sg_update_image:void(img:sg_image, data:sg_image_content ptr)
function sg_append_buffer:int(buf:sg_buffer, data_ptr:void ptr, data_size:int)
function sg_query_buffer_overflow:bool(buf:sg_buffer)

'/* rendering functions  */
function sg_begin_default_pass:void(pass_action:sg_pass_action ptr , width:int, height:int)
function sg_begin_pass:void(pass:sg_pass, pass_action:sg_pass_action ptr)
function sg_apply_viewport:void(x:int, y:int, width:int, height:int, origin_top_left:bool)
function sg_apply_scissor_rect:void(x:int, y:int, width:int, height:int, origin_top_left:bool)
function sg_apply_pipeline:void(pip:sg_pipeline)
function sg_apply_bindings:void(bindings:sg_bindings ptr)
function sg_apply_uniforms:void(stage:sg_shader_stage, ub_index:int, data:void ptr, num_bytes:int)
function sg_draw:void(base_element:int, num_elements:int, num_instances:int)
function sg_end_pass:void()
function sg_commit:void()

'/* getting information  */
function sg_query_desc:sg_desc()
function sg_query_backend:sg_backend()
function sg_query_features:sg_features()
function sg_query_limits:sg_limits()
function sg_query_pixelformat:sg_pixelformat_info(fmt:sg_pixel_format)
'/* get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID)  */
function sg_query_buffer_state:sg_resource_state(buf:sg_buffer)
function sg_query_image_state:sg_resource_state(img:sg_image)
function sg_query_shader_state:sg_resource_state(shd:sg_shader)
function sg_query_pipeline_state:sg_resource_state(pip:sg_pipeline)
function sg_query_pass_state:sg_resource_state(pass:sg_pass)
'/* get runtime information about a resource  */
function sg_query_buffer_info:sg_buffer_info(buf:sg_buffer)
function sg_query_image_info:sg_image_info(img:sg_image)
function sg_query_shader_info:sg_shader_info(shd:sg_shader)
function sg_query_pipeline_info:sg_pipeline_info(pip:sg_pipeline)
function sg_query_pass_info:sg_pass_info(pass:sg_pass)
'/* get resource creation desc struct with their default values replaced  */
function sg_query_buffer_defaults:sg_buffer_desc(desc:sg_buffer_desc ptr)
function sg_query_image_defaults:sg_image_desc(desc:sg_image_desc ptr)
function sg_query_shader_defaults:sg_shader_desc(desc:sg_shader_desc ptr)
function sg_query_pipeline_defaults:sg_pipeline_desc(desc:sg_pipeline_desc ptr)
function sg_query_pass_defaults:sg_pass_desc(desc:sg_pass_desc ptr)

'/* separate resource allocation and initialization (for async setup)  */
function sg_alloc_buffer:sg_buffer()
function sg_alloc_image:sg_image()
function sg_alloc_shader:sg_shader()
function sg_alloc_pipeline:sg_pipeline()
function sg_alloc_pass:sg_pass()
function sg_dealloc_buffer:void(buf_id:sg_buffer)
function sg_dealloc_image:void(img_id:sg_image)
function sg_dealloc_shader:void(shd_id:sg_shader)
function sg_dealloc_pipeline:void(pip_id:sg_pipeline)
function sg_dealloc_pass:void(pass_id:sg_pass)
function sg_init_buffer:void(buf_id:sg_buffer, desc:sg_buffer_desc ptr)
function sg_init_image:void(img_id:sg_image, desc:sg_image_desc ptr)
function sg_init_shader:void(shd_id:sg_shader, desc:sg_shader_desc ptr)
function sg_init_pipeline:void(pip_id:sg_pipeline, desc:sg_pipeline_desc ptr)
function sg_init_pass:void(pass_id:sg_pass, desc:sg_pass_desc ptr)
function sg_uninit_buffer:void(buf_id:sg_buffer)
function sg_uninit_image:void(img_id:sg_image)
function sg_uninit_shader:void(shd_id:sg_shader)
function sg_uninit_pipeline:void(pip_id:sg_pipeline)
function sg_uninit_pass:void(pass_id:sg_pass)
function sg_fail_buffer:void(buf_id:sg_buffer)
function sg_fail_image:void(img_id:sg_image)
function sg_fail_shader:void(shd_id:sg_shader)
function sg_fail_pipeline:void(pip_id:sg_pipeline)
function sg_fail_pass:void(pass_id:sg_pass)

'/* rendering contexts (optional)  */
function sg_setup_context:sg_context()
function sg_activate_context:void(ctx_id:sg_context)
function sg_discard_context:void(ctx_id:sg_context)

#rem
   Backend-specific helper functions, these may come in handy for mixing
   sokol-gfx rendering with 'native backend' rendering functions.

   This group of functions will be expanded as needed.
#end

'/* D3D11: return ID3D11Device */
function sg_d3d11_device:void ptr()

'/* Metal: return __bridge-casted MTLDevice */
function sg_mtl_device:void ptr()

'/* Metal: return __bridge-casted MTLRenderCommandEncoder in current pass (or zero if outside pass) */
function sg_mtl_render_command_encoder:void ptr()


